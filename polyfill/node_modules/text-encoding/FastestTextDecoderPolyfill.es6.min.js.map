{"version":3,"file":"FastestTextDecoderPolyfill.es6.min.js","sources":["../../../js/src/text-encoding/FastestTextDecoderPolyfill.js"],"sourcesContent":["(function (window) {\n  \"use strict\";\n  var log = Math.log;\n  var LN2 = Math.LN2;\n  var clz32 =\n    Math.clz32 ||\n    function (x) {\n      return (31 - log(x >>> 0) / LN2) | 0;\n    };\n  var fromCharCode = String.fromCharCode;\n  var Object_prototype_toString = {}.toString;\n  var NativeSharedArrayBuffer = window[\"SharedArrayBuffer\"];\n  var sharedArrayBufferString = NativeSharedArrayBuffer\n    ? Object_prototype_toString.call(NativeSharedArrayBuffer)\n    : \"\";\n  var NativeUint8Array = window.Uint8Array;\n  var patchedU8Array = NativeUint8Array || Array;\n  var arrayBufferString = Object_prototype_toString.call(\n    (NativeUint8Array ? ArrayBuffer : patchedU8Array).prototype\n  );\n  function decoderReplacer(encoded) {\n    var cp0 = encoded.charCodeAt(0),\n      codePoint = 0x110000,\n      i = 0,\n      stringLen = encoded.length | 0,\n      result = \"\";\n    switch (cp0 >>> 4) {\n      // no 1 byte sequences\n      case 12:\n      case 13:\n        codePoint = ((cp0 & 0x1f) << 6) | (encoded.charCodeAt(1) & 0x3f);\n        i = codePoint < 0x80 ? 0 : 2;\n        break;\n      case 14:\n        codePoint =\n          ((cp0 & 0x0f) << 12) |\n          ((encoded.charCodeAt(1) & 0x3f) << 6) |\n          (encoded.charCodeAt(2) & 0x3f);\n        i = codePoint < 0x800 ? 0 : 3;\n        break;\n      case 15:\n        if (cp0 >>> 3 === 30) {\n          codePoint =\n            ((cp0 & 0x07) << 18) |\n            ((encoded.charCodeAt(1) & 0x3f) << 12) |\n            ((encoded.charCodeAt(2) & 0x3f) << 6) |\n            encoded.charCodeAt(3);\n          i = codePoint < 0x10000 ? 0 : 4;\n        }\n    }\n    if (i) {\n      if (stringLen < i) {\n        i = 0;\n      } else if (codePoint < 0x10000) {\n        // BMP code point\n        result = fromCharCode(codePoint);\n      } else if (codePoint < 0x110000) {\n        codePoint = (codePoint - 0x10080) | 0; //- 0x10000|0;\n        result = fromCharCode(\n          ((codePoint >>> 10) + 0xd800) | 0, // highSurrogate\n          ((codePoint & 0x3ff) + 0xdc00) | 0 // lowSurrogate\n        );\n      } else i = 0; // to fill it in with INVALIDs\n    }\n\n    for (; i < stringLen; i = (i + 1) | 0) result += \"\\ufffd\"; // fill rest with replacement character\n\n    return result;\n  }\n  function TextDecoder(_, opts) {\n    /*this[\"ignoreBOM\"] = !!opts && !!opts[\"ignoreBOM\"]*/\n  }\n  TextDecoder[\"prototype\"][\"decode\"] = function (inputArrayOrBuffer) {\n    var buffer =\n      (inputArrayOrBuffer && inputArrayOrBuffer.buffer) || inputArrayOrBuffer;\n    var asObjectString = Object_prototype_toString.call(buffer);\n    if (\n      asObjectString !== arrayBufferString &&\n      asObjectString !== sharedArrayBufferString &&\n      inputArrayOrBuffer !== undefined\n    )\n      throw TypeError(\n        \"Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\"\n      );\n    var inputAs8 = NativeUint8Array ? new patchedU8Array(buffer) : buffer;\n    var resultingString = \"\";\n    for (\n      var index = 0 /*inputAs8[0]!==0xEF||inputAs8[1]!==0xBB||inputAs8[2]!==0xBF||this[\"ignoreBOM\"]?0:3*/,\n        len = inputAs8.length | 0;\n      index < len;\n      index = (index + 32768) | 0\n    )\n      resultingString += fromCharCode.apply(\n        0,\n        inputAs8[NativeUint8Array ? \"subarray\" : \"slice\"](\n          index,\n          (index + 32768) | 0\n        )\n      );\n\n    return resultingString.replace(\n      /[\\xc0-\\xff][\\x80-\\xbf]+|[\\x80-\\xff]/g,\n      decoderReplacer\n    );\n  };\n  if (!window[\"TextDecoder\"]) window[\"TextDecoder\"] = TextDecoder;\n})(\n  typeof global == \"\" + void 0\n    ? typeof self == \"\" + void 0\n      ? globalThis\n      : self\n    : global\n);\n"],"names":["window","fromCharCode","String","Object_prototype_toString","toString","NativeSharedArrayBuffer","sharedArrayBufferString","call","NativeUint8Array","Uint8Array","patchedU8Array","Array","arrayBufferString","ArrayBuffer","prototype","decoderReplacer","encoded","cp0","charCodeAt","codePoint","i","stringLen","length","result","TextDecoder","_","opts","inputArrayOrBuffer","buffer","asObjectString","undefined","TypeError","inputAs8","resultingString","index","len","apply","replace","global","self","globalThis"],"mappings":"4bAAA,SAAWA,QAST,IAAIC,aAAeC,OAAOD,aACtBE,0BAA4B,CAAE,EAACC,SAC/BC,wBAA0BL,OAA0B,kBACpDM,wBAA0BD,wBAC1BF,0BAA0BI,KAAKF,yBAC/B,GACAG,iBAAmBR,OAAOS,WAC1BC,eAAiBF,kBAAoBG,MACrCC,kBAAoBT,0BAA0BI,MAC/CC,iBAAmBK,YAAcH,gBAAgBI,WAEpD,SAASC,gBAAgBC,SACvB,IAAIC,IAAMD,QAAQE,WAAW,GAC3BC,UAAY,QACZC,EAAI,EACJC,UAA6B,EAAjBL,QAAQM,OACpBC,OAAS,GACX,OAAQN,MAAQ,GAEd,KAAK,GACL,KAAK,GAEHG,GADAD,WAAoB,GAANF,MAAe,EAA8B,GAAxBD,QAAQE,WAAW,IACtC,IAAO,EAAI,EAC3B,MACF,KAAK,GAKHE,GAJAD,WACU,GAANF,MAAe,IACS,GAAxBD,QAAQE,WAAW,KAAc,EACV,GAAxBF,QAAQE,WAAW,IACN,KAAQ,EAAI,EAC5B,MACF,KAAK,GACCD,MAAQ,GAAM,KAMhBG,GALAD,WACU,EAANF,MAAe,IACS,GAAxBD,QAAQE,WAAW,KAAc,IACT,GAAxBF,QAAQE,WAAW,KAAc,EACnCF,QAAQE,WAAW,IACL,MAAU,EAAI,GAkBpC,IAfIE,IACEC,UAAYD,EACdA,EAAI,EACKD,UAAY,MAErBI,OAAStB,aAAakB,WACbA,UAAY,QAErBI,OAAStB,aACe,QAFxBkB,UAAaA,UAAY,MAAW,KAElB,IAAgB,EACT,OAAT,KAAZA,WAA+B,GAE9BC,EAAI,GAGNA,EAAIC,UAAWD,EAAKA,EAAI,EAAK,EAAGG,QAAU,IAEjD,OAAOA,MACR,CACD,SAASC,YAAYC,EAAGC,MAEvB,CACDF,YAAuB,UAAU,OAAI,SAAUG,oBAC7C,IAAIC,OACDD,oBAAsBA,mBAAmBC,QAAWD,mBACnDE,eAAiB1B,0BAA0BI,KAAKqB,QACpD,GACEC,iBAAmBjB,mBACnBiB,iBAAmBvB,8BACIwB,IAAvBH,mBAEA,MAAMI,UACJ,qHAIJ,IAFA,IAAIC,SAAWxB,iBAAmB,IAAIE,eAAekB,QAAUA,OAC3DK,gBAAkB,GAEhBC,MAAQ,EACVC,IAAwB,EAAlBH,SAASV,OACjBY,MAAQC,IACRD,MAASA,MAAQ,MAAS,EAE1BD,iBAAmBhC,aAAamC,MAC9B,EACAJ,SAASxB,iBAAmB,WAAa,SACvC0B,MACCA,MAAQ,MAAS,IAIxB,OAAOD,gBAAgBI,QACrB,uCACAtB,gBAEN,EACOf,OAAoB,cAAGA,OAAoB,YAAIwB,YACrD,CA1GD,QA2GSc,gBAAU,QAAK,SACXC,MAAQ,QAAK,EAClBC,WACAD,KACFD"}
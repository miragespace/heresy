{"version":3,"file":"polyfill.es6.min.js","sources":["../../../js/src/react-native-fetch/utils.ts","../../../js/src/react-native-fetch/Headers.ts","../../../js/src/react-native-fetch/Body.ts","../../../js/src/react-native-fetch/Request.ts","../../../js/src/react-native-fetch/Response.ts","../../../js/src/react-native-fetch/polyfill.ts"],"sourcesContent":["function getGlobals() {\n  if (typeof self !== \"undefined\") {\n    return self;\n  } else if (typeof window !== \"undefined\") {\n    return window;\n  } else if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  return undefined;\n}\n\nasync function drainStream(stream: ReadableStream<any>): Promise<Uint8Array> {\n  const chunks: any[] = [];\n  const reader = stream.getReader();\n\n  async function readNextChunk(): Promise<any> {\n    const { done, value } = await reader.read();\n    if (done) {\n      return chunks.reduce((bytes, chunk) => [...bytes, ...chunk], []);\n    }\n    chunks.push(value);\n    return readNextChunk();\n  }\n\n  const bytes = await readNextChunk();\n\n  return new Uint8Array(bytes);\n}\n\nfunction readArrayBufferAsText(array: ArrayBuffer) {\n  const decoder = new TextDecoder();\n\n  return decoder.decode(array);\n}\n\nexport { drainStream, readArrayBufferAsText };\n\nexport const globals = getGlobals();\n","function normalizeName(name: string) {\n  if (typeof name !== \"string\") {\n    name = String(name);\n  }\n\n  name = name.trim();\n\n  if (name.length === 0) {\n    throw new TypeError(\"Header field name is empty\");\n  }\n\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name)) {\n    throw new TypeError(`Invalid character in header field name: ${name}`);\n  }\n\n  return name.toLowerCase();\n}\n\nfunction normalizeValue(value: string | number) {\n  if (typeof value !== \"string\") {\n    value = String(value);\n  }\n  return value;\n}\n\nexport type HeadersInit =\n  | Headers\n  | Record<string, string>\n  | [key: string, value: string][];\n\nexport default class Headers {\n  map: Map<string, string> = new Map();\n\n  constructor(init?: HeadersInit) {\n    if (init instanceof Headers) {\n      init.forEach((value: string, name: string) => {\n        this.append(name, value);\n      });\n\n      return this;\n    }\n\n    if (Array.isArray(init)) {\n      init.forEach(([name, value]) => {\n        this.append(name, value);\n      });\n\n      return this;\n    }\n\n    if (init) {\n      for (const name in init) {\n        this.append(name, init[name]);\n      }\n    }\n  }\n\n  append(name: string, value: string): void {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    const oldValue = this.get(name);\n    // From MDN: If the specified header already exists and accepts multiple values, append() will append the new value to the end of the value set.\n    // However, we're a missing a check on whether the header does indeed accept multiple values\n    this.map.set(name, oldValue ? oldValue + \", \" + value : value);\n  }\n\n  delete(name: string): void {\n    this.map.delete(normalizeName(name));\n  }\n\n  get(name: string): string | null {\n    name = normalizeName(name);\n    return this.map.get(name) ?? null;\n  }\n\n  has(name: string): boolean {\n    return this.map.has(normalizeName(name));\n  }\n\n  set(name: string, value: string | number): void {\n    this.map.set(normalizeName(name), normalizeValue(value));\n  }\n\n  forEach(\n    callback: (value: string, key: string, parent?: object) => void,\n    thisArg?: object\n  ): void {\n    this.map.forEach((value, name) => {\n      callback.call(thisArg, value, name, this);\n    }, this);\n  }\n\n  keys(): IterableIterator<string> {\n    return this.map.keys();\n  }\n\n  values(): IterableIterator<string> {\n    return this.map.values();\n  }\n\n  entries(): IterableIterator<[string, string]> {\n    return this.map.entries();\n  }\n\n  [Symbol.iterator](): IterableIterator<[string, string]> {\n    return this.entries();\n  }\n}\n","import { drainStream, readArrayBufferAsText } from \"./utils\";\n\nexport type BodyInit = URLSearchParams | ArrayBuffer | ReadableStream | string;\n\nexport default abstract class Body {\n  readonly bodyInit: BodyInit | null;\n  _mimeType?: string;\n  _bodyText: string;\n  _bodyArrayBuffer: ArrayBuffer;\n  _bodyReadableStream: ReadableStream;\n  _consumed: boolean;\n\n  constructor(body: BodyInit | null) {\n    this.bodyInit = body;\n\n    if (body instanceof URLSearchParams) {\n      // URLSearchParams is not handled natively so we reassign bodyInit for fetch to send it as text\n      this._bodyText = this.bodyInit = body.toString();\n      this._mimeType = \"application/x-www-form-urlencoded;charset=UTF-8\";\n      return this;\n    }\n\n    if (body instanceof ArrayBuffer) {\n      this._bodyArrayBuffer = body.slice(0);\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (ArrayBuffer.isView(body)) {\n      this._bodyArrayBuffer = body.buffer;\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (body instanceof ReadableStream) {\n      this._bodyReadableStream = body;\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (body) {\n      this._bodyText = body.toString();\n      this._mimeType = \"text/plain;charset=UTF-8\";\n    }\n  }\n\n  __consumed() {\n    if (this._consumed) {\n      return Promise.reject(new TypeError(\"Already read\"));\n    }\n    this._consumed = true;\n  }\n\n  async arrayBuffer() {\n    const alreadyConsumed = this.__consumed();\n    if (alreadyConsumed) {\n      return alreadyConsumed;\n    }\n\n    if (this._bodyReadableStream) {\n      const typedArray = await drainStream(this._bodyReadableStream);\n\n      return typedArray.buffer;\n    }\n\n    if (this._bodyArrayBuffer) {\n      if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n        const { buffer, byteOffset, byteLength } = this._bodyArrayBuffer;\n\n        return Promise.resolve(\n          buffer.slice(byteOffset, byteOffset + byteLength)\n        );\n      }\n\n      return Promise.resolve(this._bodyArrayBuffer);\n    }\n\n    const text = this._bodyText;\n    const encoder = new TextEncoder();\n\n    return encoder.encode(text);\n  }\n\n  async text() {\n    const alreadyConsumed = this.__consumed();\n    if (alreadyConsumed) {\n      return alreadyConsumed;\n    }\n\n    if (this._bodyReadableStream) {\n      const typedArray = await drainStream(this._bodyReadableStream);\n\n      return readArrayBufferAsText(typedArray);\n    }\n\n    if (this._bodyArrayBuffer) {\n      return readArrayBufferAsText(this._bodyArrayBuffer);\n    }\n\n    return this._bodyText;\n  }\n\n  async json<T>(): Promise<T> {\n    const text = await this.text();\n\n    return JSON.parse(text);\n  }\n\n  get body(): ReadableStream | null {\n    if (this._bodyReadableStream) {\n      return this._bodyReadableStream;\n    }\n\n    if (this._bodyArrayBuffer) {\n      const typedArray = new Uint8Array(this._bodyArrayBuffer);\n\n      return new ReadableStream({\n        start(controller) {\n          typedArray.forEach((chunk) => {\n            controller.enqueue(chunk);\n          });\n\n          controller.close();\n        },\n      });\n    }\n\n    if (this._bodyText) {\n      const text = this._bodyText;\n      const encoder = new TextEncoder();\n\n      return new ReadableStream({\n        start: async (controller) => {\n          const typedArray = new Uint8Array(encoder.encode(text));\n\n          typedArray.forEach((chunk) => {\n            controller.enqueue(chunk);\n          });\n\n          controller.close();\n        },\n      });\n    }\n\n    return null;\n  }\n\n  get bodyUsed(): boolean {\n    return this._consumed;\n  }\n}\n","import Body, { BodyInit } from \"./Body\";\nimport Headers, { HeadersInit } from \"./Headers\";\n\nexport type Method = \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"OPTIONS\";\n\nexport interface RequestInit {\n  method?: Method;\n  headers?: HeadersInit;\n  body?: BodyInit | null;\n}\n\nexport default class Request extends Body {\n  readonly url: string;\n  readonly headers: Headers;\n  readonly method: Method;\n\n  constructor(input: Request | string, options: Request | RequestInit) {\n    if (input instanceof Request) {\n      if (input.bodyInit && input.bodyUsed) {\n        throw new TypeError(\"Already read\");\n      }\n      super(input.body);\n\n      this.url = input.url;\n      this.method = input.method;\n      this.headers = new Headers(options.headers ?? input.headers);\n\n      if (input.bodyInit) {\n        input._consumed = true;\n      }\n    } else {\n      if (options instanceof Request) {\n        if (options.bodyInit && options.bodyUsed) {\n          throw new TypeError(\"Already read\");\n        }\n        super(options.body);\n\n        if (options.bodyInit) {\n          options._consumed = true;\n        }\n      } else {\n        super(options.body ?? null);\n      }\n      this.url = input;\n      this.method = options.method || \"GET\";\n      this.headers = this.headers ?? new Headers(options.headers);\n    }\n\n    if (this.bodyInit && [\"GET\", \"HEAD\"].includes(this.method)) {\n      throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n    }\n\n    if (this.bodyInit) {\n      if (!this.headers.has(\"content-type\") && this._mimeType) {\n        this.headers.set(\"content-type\", this._mimeType);\n      }\n    }\n  }\n\n  clone() {\n    return new Request(this, { body: this.bodyInit });\n  }\n}\n","import Body, { BodyInit } from \"./Body\";\nimport Headers, { HeadersInit } from \"./Headers\";\n\nexport interface ResponseInit {\n  status?: number;\n  statusText?: string;\n  headers?: HeadersInit;\n}\n\nexport default class Response extends Body {\n  readonly ok: boolean;\n  readonly status: number;\n  readonly statusText: string;\n  readonly headers: Headers;\n  readonly url: string;\n\n  constructor(body: BodyInit | null, options: ResponseInit | Response) {\n    super(body);\n    this.status = options.status ?? 200;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = options.statusText ?? \"\";\n    this.headers = new Headers(options.headers);\n\n    if (options instanceof Response) {\n      this.url = options.url;\n    } else {\n      this.url = \"\";\n    }\n\n    if (!this.headers.has(\"content-type\") && this._mimeType) {\n      this.headers.set(\"content-type\", this._mimeType);\n    }\n  }\n\n  clone() {\n    return new Response(this.bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url,\n    });\n  }\n\n  static redirect(url: string, status: number) {\n    const redirectStatuses = [301, 302, 303, 307, 308];\n\n    if (!redirectStatuses.includes(status)) {\n      throw new RangeError(`Invalid status code: ${status}`);\n    }\n\n    return new Response(null, { status: status, headers: { location: url } });\n  }\n}\n","import { globals } from \"./utils\";\nimport Headers from \"./Headers\";\nimport Request from \"./Request\";\nimport Response from \"./Response\";\n\nconst m = {\n  Headers,\n  Request,\n  Response,\n};\n\n// Add classes to global scope\nif (typeof globals !== \"undefined\") {\n  for (const prop in m) {\n    if (Object.prototype.hasOwnProperty.call(m, prop)) {\n      Object.defineProperty(globals, prop, {\n        value: m[prop as keyof typeof m],\n        writable: true,\n        configurable: true,\n      });\n    }\n  }\n}\n"],"names":["async","drainStream","stream","chunks","reader","getReader","bytes","readNextChunk","done","value","read","reduce","chunk","push","Uint8Array","readArrayBufferAsText","array","TextDecoder","decode","globals","self","window","globalThis","normalizeName","name","String","trim","length","TypeError","test","toLowerCase","normalizeValue","Headers","constructor","init","this","map","Map","forEach","append","Array","isArray","oldValue","get","set","delete","_a","has","callback","thisArg","call","keys","values","entries","Symbol","iterator","Body","body","bodyInit","URLSearchParams","_bodyText","toString","_mimeType","ArrayBuffer","_bodyArrayBuffer","slice","isView","buffer","ReadableStream","_bodyReadableStream","__consumed","_consumed","Promise","reject","alreadyConsumed","byteOffset","byteLength","resolve","text","TextEncoder","encode","JSON","parse","typedArray","start","controller","enqueue","close","encoder","bodyUsed","Request","input","options","super","url","method","headers","_b","_c","includes","clone","Response","status","ok","statusText","static","RangeError","location","m","prop","Object","prototype","hasOwnProperty","defineProperty","writable","configurable"],"mappings":"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"}
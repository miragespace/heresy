{"version":3,"file":"polyfill.es6.min.js","sources":["../../../js/src/react-native-fetch/utils.ts","../../../js/src/react-native-fetch/Headers.ts","../../../js/src/react-native-fetch/Body.ts","../../../js/src/react-native-fetch/Request.ts","../../../js/src/react-native-fetch/Response.ts","../../../js/src/react-native-fetch/FetchEvent.ts","../../../js/src/react-native-fetch/polyfill.ts"],"sourcesContent":["function getGlobals() {\n  if (typeof self !== \"undefined\") {\n    return self;\n  } else if (typeof window !== \"undefined\") {\n    return window;\n  } else if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  return undefined;\n}\n\nasync function drainStream(stream: ReadableStream<any>): Promise<Uint8Array> {\n  const chunks: any[] = [];\n  const reader = stream.getReader({ mode: \"byob\" });\n  const buffer = new ArrayBuffer(8192);\n  const view = new Uint8Array(buffer);\n\n  async function readNextChunk(): Promise<any> {\n    const { done, value } = await reader.read(view);\n    if (done) {\n      return chunks.reduce((bytes, chunk) => [...bytes, ...chunk], []);\n    }\n    chunks.push(value);\n    return readNextChunk();\n  }\n\n  const bytes = await readNextChunk();\n\n  return new Uint8Array(bytes);\n}\n\nfunction readArrayBufferAsText(array: ArrayBuffer) {\n  const decoder = new TextDecoder();\n\n  return decoder.decode(array);\n}\n\nexport { drainStream, readArrayBufferAsText };\n\nexport const globals = getGlobals();\n","function normalizeName(name: string) {\n  if (typeof name !== \"string\") {\n    name = String(name);\n  }\n\n  name = name.trim();\n\n  if (name.length === 0) {\n    throw new TypeError(\"Header field name is empty\");\n  }\n\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name)) {\n    throw new TypeError(`Invalid character in header field name: ${name}`);\n  }\n\n  return name.toLowerCase();\n}\n\nfunction normalizeValue(value: string | number) {\n  if (typeof value !== \"string\") {\n    value = String(value);\n  }\n  return value;\n}\n\nfunction iteratorFor<R = any>(items: R[]): IterableIterator<R> {\n  var dummyR: R;\n  var iterator = {\n    next(): IteratorResult<R> {\n      var value = items.shift();\n      return { done: value === undefined, value: value ?? dummyR };\n    },\n    [Symbol.iterator]() {\n      return iterator;\n    },\n  };\n\n  return iterator;\n}\n\nexport type HeadersInit =\n  | Headers\n  | Record<string, string>\n  | [key: string, value: string][];\n\nexport default class Headers {\n  map: Record<string, string> = {};\n\n  constructor(init?: HeadersInit) {\n    if (init instanceof Headers) {\n      init.forEach((value: string, name: string) => {\n        this.append(name, value);\n      });\n\n      return this;\n    }\n\n    if (Array.isArray(init)) {\n      init.forEach(([name, value]) => {\n        this.append(name, value);\n      });\n\n      return this;\n    }\n\n    if (init) {\n      for (const name in init) {\n        this.append(name, init[name]);\n      }\n    }\n  }\n\n  append(name: string, value: string): void {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    const oldValue = this.map[name];\n    // From MDN: If the specified header already exists and accepts multiple values, append() will append the new value to the end of the value set.\n    // However, we're a missing a check on whether the header does indeed accept multiple values\n    this.map[name] = oldValue ? oldValue + \", \" + value : value;\n  }\n\n  get(name: string): string | null {\n    name = normalizeName(name);\n    return this.map[name] ?? null;\n  }\n\n  has(name: string): boolean {\n    return this.map.hasOwnProperty(normalizeName(name));\n  }\n\n  set(name: string, value: string | number): void {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  }\n\n  forEach(\n    callback: (value: string, key: string, parent?: object) => void,\n    thisArg?: object\n  ): void {\n    for (const key in this.map) {\n      callback.call(thisArg, this.map[key], key, this);\n    }\n  }\n\n  keys(): IterableIterator<string> {\n    return iteratorFor(Object.keys(this.map));\n  }\n\n  values(): IterableIterator<string> {\n    return iteratorFor(Object.values(this.map));\n  }\n\n  entries(): IterableIterator<[string, string]> {\n    var items: [string, string][] = [];\n    this.forEach((value, name) => {\n      items.push([name, value]);\n    });\n    return iteratorFor(items);\n  }\n\n  [Symbol.iterator](): IterableIterator<[string, string]> {\n    return this.entries();\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Headers\";\n  }\n}\n","import { drainStream, readArrayBufferAsText } from \"./utils\";\n\nexport type BodyInit = URLSearchParams | ArrayBuffer | ReadableStream | string;\n\nexport default abstract class Body {\n  readonly bodyInit: BodyInit | null;\n  _mimeType?: string;\n  _bodyText: string;\n  _bodyArrayBuffer: ArrayBuffer;\n  _bodyReadableStream: ReadableStream;\n  _consumed: boolean;\n\n  constructor(body: BodyInit | null) {\n    this.bodyInit = body;\n\n    if (body instanceof URLSearchParams) {\n      // URLSearchParams is not handled natively so we reassign bodyInit for fetch to send it as text\n      this._bodyText = this.bodyInit = body.toString();\n      this._mimeType = \"application/x-www-form-urlencoded;charset=UTF-8\";\n      return this;\n    }\n\n    if (body instanceof ArrayBuffer) {\n      this._bodyArrayBuffer = body.slice(0);\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (ArrayBuffer.isView(body)) {\n      this._bodyArrayBuffer = body.buffer;\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (body instanceof ReadableStream) {\n      this._bodyReadableStream = body;\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (body) {\n      this._bodyText = body.toString();\n      this._mimeType = \"text/plain;charset=UTF-8\";\n    }\n  }\n\n  __consumed() {\n    if (this._consumed) {\n      return Promise.reject(new TypeError(\"Already read\"));\n    }\n    this._consumed = true;\n  }\n\n  async arrayBuffer() {\n    const alreadyConsumed = this.__consumed();\n    if (alreadyConsumed) {\n      return alreadyConsumed;\n    }\n\n    if (this._bodyReadableStream) {\n      const typedArray = await drainStream(this._bodyReadableStream);\n\n      return typedArray.buffer;\n    }\n\n    if (this._bodyArrayBuffer) {\n      if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n        const { buffer, byteOffset, byteLength } = this._bodyArrayBuffer;\n\n        return Promise.resolve(\n          buffer.slice(byteOffset, byteOffset + byteLength)\n        );\n      }\n\n      return Promise.resolve(this._bodyArrayBuffer);\n    }\n\n    const text = this._bodyText;\n    const encoder = new TextEncoder();\n\n    return encoder.encode(text);\n  }\n\n  async text() {\n    const alreadyConsumed = this.__consumed();\n    if (alreadyConsumed) {\n      return alreadyConsumed;\n    }\n\n    if (this._bodyReadableStream) {\n      const typedArray = await drainStream(this._bodyReadableStream);\n\n      return readArrayBufferAsText(typedArray);\n    }\n\n    if (this._bodyArrayBuffer) {\n      return readArrayBufferAsText(this._bodyArrayBuffer);\n    }\n\n    return this._bodyText;\n  }\n\n  async json<T>(): Promise<T> {\n    const text = await this.text();\n\n    return JSON.parse(text);\n  }\n\n  get body(): ReadableStream | null {\n    if (this._bodyReadableStream) {\n      return this._bodyReadableStream;\n    }\n\n    if (this._bodyArrayBuffer) {\n      const typedArray = new Uint8Array(this._bodyArrayBuffer);\n\n      return new ReadableStream({\n        start(controller) {\n          typedArray.forEach((chunk) => {\n            controller.enqueue(chunk);\n          });\n\n          controller.close();\n        },\n      });\n    }\n\n    if (this._bodyText) {\n      const text = this._bodyText;\n      const encoder = new TextEncoder();\n\n      return new ReadableStream({\n        start: async (controller) => {\n          const typedArray = new Uint8Array(encoder.encode(text));\n\n          typedArray.forEach((chunk) => {\n            controller.enqueue(chunk);\n          });\n\n          controller.close();\n        },\n      });\n    }\n\n    return null;\n  }\n\n  get bodyUsed(): boolean {\n    return this._consumed;\n  }\n}\n","import Body, { BodyInit } from \"./Body\";\nimport Headers, { HeadersInit } from \"./Headers\";\n\nexport type Method = \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"OPTIONS\";\n\nexport interface RequestInit {\n  method?: Method;\n  headers?: HeadersInit;\n  body?: BodyInit | null;\n}\n\nexport default class Request extends Body {\n  readonly url: string;\n  readonly headers: Headers;\n  readonly method: Method;\n\n  constructor(input: Request | string, options?: Request | RequestInit) {\n    if (input instanceof Request) {\n      if (input.bodyInit && input.bodyUsed) {\n        throw new TypeError(\"Already read\");\n      }\n      super(input.body);\n\n      this.url = input.url;\n      this.method = input.method;\n      this.headers = new Headers(options?.headers ?? input.headers);\n\n      if (input.bodyInit) {\n        input._consumed = true;\n      }\n    } else {\n      if (options instanceof Request) {\n        if (options.bodyInit && options.bodyUsed) {\n          throw new TypeError(\"Already read\");\n        }\n        super(options.body);\n\n        if (options.bodyInit) {\n          options._consumed = true;\n        }\n      } else {\n        super(options?.body ?? null);\n      }\n      this.url = input;\n      this.method = options?.method || \"GET\";\n      this.headers = this.headers ?? new Headers(options?.headers);\n    }\n\n    if (this.bodyInit && [\"GET\", \"HEAD\"].includes(this.method)) {\n      throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n    }\n\n    if (this.bodyInit) {\n      if (!this.headers.has(\"content-type\") && this._mimeType) {\n        this.headers.set(\"content-type\", this._mimeType);\n      }\n    }\n  }\n\n  clone() {\n    return new Request(this, { body: this.bodyInit });\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Request\";\n  }\n}\n","import Body, { BodyInit } from \"./Body\";\nimport Headers, { HeadersInit } from \"./Headers\";\n\nexport interface ResponseInit {\n  status?: number;\n  statusText?: string;\n  headers?: HeadersInit;\n}\n\nexport default class Response extends Body {\n  readonly ok: boolean;\n  readonly status: number;\n  readonly statusText: string;\n  readonly headers: Headers;\n  readonly url: string;\n\n  constructor(body: BodyInit | null, options?: ResponseInit | Response) {\n    super(body);\n    this.status = options?.status ?? 200;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = options?.statusText ?? \"\";\n    this.headers = new Headers(options?.headers);\n\n    if (options instanceof Response) {\n      this.url = options.url;\n    } else {\n      this.url = \"\";\n    }\n\n    if (!this.headers.has(\"content-type\") && this._mimeType) {\n      this.headers.set(\"content-type\", this._mimeType);\n    }\n  }\n\n  clone() {\n    return new Response(this.bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url,\n    });\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Response\";\n  }\n\n  static redirect(url: string, status: number) {\n    const redirectStatuses = [301, 302, 303, 307, 308];\n\n    if (!redirectStatuses.includes(status)) {\n      throw new RangeError(`Invalid status code: ${status}`);\n    }\n\n    return new Response(null, { status: status, headers: { location: url } });\n  }\n}\n","import Request from \"./Request\";\nimport Response from \"./Response\";\n\nexport default class FetchEvent {\n  respondWith(response: Response | Promise<Response>): void {} // implemented in Go, here only for prototype\n  waitUntil(promise: Promise<any>): void {} // implemented in Go, here only for prototype\n  readonly request: Request;\n\n  get [Symbol.toStringTag]() {\n    return \"FetchEvent\";\n  }\n}\n","import { globals } from \"./utils\";\nimport Headers from \"./Headers\";\nimport Request from \"./Request\";\nimport Response from \"./Response\";\nimport FetchEvent from \"./FetchEvent\";\n\nconst m = {\n  Headers,\n  Request,\n  Response,\n  FetchEvent,\n};\n\n// Add classes to global scope\nif (typeof globals !== \"undefined\") {\n  for (const prop in m) {\n    if (Object.prototype.hasOwnProperty.call(m, prop)) {\n      Object.defineProperty(globals, prop, {\n        value: m[prop as keyof typeof m],\n        writable: true,\n        configurable: true,\n      });\n    }\n  }\n}\n"],"names":["async","drainStream","stream","chunks","reader","getReader","mode","buffer","ArrayBuffer","view","Uint8Array","bytes","readNextChunk","done","value","read","reduce","chunk","push","readArrayBufferAsText","array","TextDecoder","decode","globals","getGlobals","self","window","globalThis","normalizeName","name","String","trim","length","TypeError","test","toLowerCase","normalizeValue","iteratorFor","items","iterator","next","shift","undefined","dummyR","Symbol","Headers","constructor","init","this","map","forEach","append","Array","isArray","oldValue","get","_a","has","hasOwnProperty","set","callback","thisArg","key","call","keys","Object","values","entries","toStringTag","Body","body","bodyInit","URLSearchParams","_bodyText","toString","_mimeType","_bodyArrayBuffer","slice","isView","ReadableStream","_bodyReadableStream","__consumed","_consumed","Promise","reject","alreadyConsumed","byteOffset","byteLength","resolve","text","TextEncoder","encode","JSON","parse","typedArray","start","controller","enqueue","close","encoder","bodyUsed","Request","input","options","super","url","method","headers","_b","_c","includes","clone","Response","status","ok","statusText","static","RangeError","location","FetchEvent","respondWith","response","waitUntil","promise","m","prop","prototype","defineProperty","writable","configurable"],"mappings":"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"}
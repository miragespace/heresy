{"version":3,"file":"polyfill.es6.min.js","sources":["../../../js/src/react-native-fetch/utils.ts","../../../js/src/react-native-fetch/Headers.ts","../../../js/src/react-native-fetch/Body.ts","../../../js/src/react-native-fetch/Request.ts","../../../js/src/react-native-fetch/Response.ts","../../../js/src/react-native-fetch/polyfill.ts"],"sourcesContent":["function getGlobals() {\n  if (typeof self !== \"undefined\") {\n    return self;\n  } else if (typeof window !== \"undefined\") {\n    return window;\n  } else if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  return undefined;\n}\n\nasync function drainStream(stream: ReadableStream<any>): Promise<Uint8Array> {\n  const chunks: any[] = [];\n  const reader = stream.getReader();\n\n  async function readNextChunk(): Promise<any> {\n    const { done, value } = await reader.read();\n    if (done) {\n      return chunks.reduce((bytes, chunk) => [...bytes, ...chunk], []);\n    }\n    chunks.push(value);\n    return readNextChunk();\n  }\n\n  const bytes = await readNextChunk();\n\n  return new Uint8Array(bytes);\n}\n\nfunction readArrayBufferAsText(array: ArrayBuffer) {\n  const decoder = new TextDecoder();\n\n  return decoder.decode(array);\n}\n\nexport { drainStream, readArrayBufferAsText };\n\nexport const globals = getGlobals();\n","function normalizeName(name: string) {\n  if (typeof name !== \"string\") {\n    name = String(name);\n  }\n\n  name = name.trim();\n\n  if (name.length === 0) {\n    throw new TypeError(\"Header field name is empty\");\n  }\n\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name)) {\n    throw new TypeError(`Invalid character in header field name: ${name}`);\n  }\n\n  return name.toLowerCase();\n}\n\nfunction normalizeValue(value: string | number) {\n  if (typeof value !== \"string\") {\n    value = String(value);\n  }\n  return value;\n}\n\nexport type HeadersInit =\n  | Headers\n  | Record<string, string>\n  | [key: string, value: string][];\n\nexport default class Headers {\n  map: Map<string, string> = new Map();\n\n  constructor(init?: HeadersInit) {\n    if (init instanceof Headers) {\n      init.forEach((value: string, name: string) => {\n        this.append(name, value);\n      });\n\n      return this;\n    }\n\n    if (Array.isArray(init)) {\n      init.forEach(([name, value]) => {\n        this.append(name, value);\n      });\n\n      return this;\n    }\n\n    if (init) {\n      for (const name in init) {\n        this.append(name, init[name]);\n      }\n    }\n  }\n\n  append(name: string, value: string): void {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    const oldValue = this.get(name);\n    // From MDN: If the specified header already exists and accepts multiple values, append() will append the new value to the end of the value set.\n    // However, we're a missing a check on whether the header does indeed accept multiple values\n    this.map.set(name, oldValue ? oldValue + \", \" + value : value);\n  }\n\n  delete(name: string): void {\n    this.map.delete(normalizeName(name));\n  }\n\n  get(name: string): string | null {\n    name = normalizeName(name);\n    return this.map.get(name) ?? null;\n  }\n\n  has(name: string): boolean {\n    return this.map.has(normalizeName(name));\n  }\n\n  set(name: string, value: string | number): void {\n    this.map.set(normalizeName(name), normalizeValue(value));\n  }\n\n  forEach(\n    callback: (value: string, key: string, parent?: object) => void,\n    thisArg?: object\n  ): void {\n    this.map.forEach((value, name) => {\n      callback.call(thisArg, value, name, this);\n    }, this);\n  }\n\n  keys(): IterableIterator<string> {\n    return this.map.keys();\n  }\n\n  values(): IterableIterator<string> {\n    return this.map.values();\n  }\n\n  entries(): IterableIterator<[string, string]> {\n    return this.map.entries();\n  }\n\n  [Symbol.iterator](): IterableIterator<[string, string]> {\n    return this.entries();\n  }\n}\n","import { drainStream, readArrayBufferAsText } from \"./utils\";\n\nexport type BodyInit = URLSearchParams | ArrayBuffer | ReadableStream | string;\n\nexport default abstract class Body {\n  readonly bodyInit: BodyInit | null;\n  _mimeType?: string;\n  _bodyText: string;\n  _bodyArrayBuffer: ArrayBuffer;\n  _bodyReadableStream: ReadableStream;\n  _consumed: boolean;\n\n  constructor(body: BodyInit | null) {\n    this.bodyInit = body;\n\n    if (body instanceof URLSearchParams) {\n      // URLSearchParams is not handled natively so we reassign bodyInit for fetch to send it as text\n      this._bodyText = this.bodyInit = body.toString();\n      this._mimeType = \"application/x-www-form-urlencoded;charset=UTF-8\";\n      return this;\n    }\n\n    if (body instanceof ArrayBuffer) {\n      this._bodyArrayBuffer = body.slice(0);\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (ArrayBuffer.isView(body)) {\n      this._bodyArrayBuffer = body.buffer;\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (body instanceof ReadableStream) {\n      this._bodyReadableStream = body;\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (body) {\n      this._bodyText = body.toString();\n      this._mimeType = \"text/plain;charset=UTF-8\";\n    }\n  }\n\n  __consumed() {\n    if (this._consumed) {\n      return Promise.reject(new TypeError(\"Already read\"));\n    }\n    this._consumed = true;\n  }\n\n  async arrayBuffer() {\n    const alreadyConsumed = this.__consumed();\n    if (alreadyConsumed) {\n      return alreadyConsumed;\n    }\n\n    if (this._bodyReadableStream) {\n      const typedArray = await drainStream(this._bodyReadableStream);\n\n      return typedArray.buffer;\n    }\n\n    if (this._bodyArrayBuffer) {\n      if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n        const { buffer, byteOffset, byteLength } = this._bodyArrayBuffer;\n\n        return Promise.resolve(\n          buffer.slice(byteOffset, byteOffset + byteLength)\n        );\n      }\n\n      return Promise.resolve(this._bodyArrayBuffer);\n    }\n\n    const text = this._bodyText;\n    const encoder = new TextEncoder();\n\n    return encoder.encode(text);\n  }\n\n  async text() {\n    const alreadyConsumed = this.__consumed();\n    if (alreadyConsumed) {\n      return alreadyConsumed;\n    }\n\n    if (this._bodyReadableStream) {\n      const typedArray = await drainStream(this._bodyReadableStream);\n\n      return readArrayBufferAsText(typedArray);\n    }\n\n    if (this._bodyArrayBuffer) {\n      return readArrayBufferAsText(this._bodyArrayBuffer);\n    }\n\n    return this._bodyText;\n  }\n\n  async json<T>(): Promise<T> {\n    const text = await this.text();\n\n    return JSON.parse(text);\n  }\n\n  get body(): ReadableStream | null {\n    if (this._bodyReadableStream) {\n      return this._bodyReadableStream;\n    }\n\n    if (this._bodyArrayBuffer) {\n      const typedArray = new Uint8Array(this._bodyArrayBuffer);\n\n      return new ReadableStream({\n        start(controller) {\n          typedArray.forEach((chunk) => {\n            controller.enqueue(chunk);\n          });\n\n          controller.close();\n        },\n      });\n    }\n\n    if (this._bodyText) {\n      const text = this._bodyText;\n      const encoder = new TextEncoder();\n\n      return new ReadableStream({\n        start: async (controller) => {\n          const typedArray = new Uint8Array(encoder.encode(text));\n\n          typedArray.forEach((chunk) => {\n            controller.enqueue(chunk);\n          });\n\n          controller.close();\n        },\n      });\n    }\n\n    return null;\n  }\n\n  get bodyUsed(): boolean {\n    return this._consumed;\n  }\n}\n","import Body, { BodyInit } from \"./Body\";\nimport Headers, { HeadersInit } from \"./Headers\";\n\nexport type Method = \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"OPTIONS\";\n\nexport interface RequestInit {\n  method?: Method;\n  headers?: HeadersInit;\n  body?: BodyInit | null;\n}\n\nexport default class Request extends Body {\n  readonly url: string;\n  readonly headers: Headers;\n  readonly method: Method;\n\n  constructor(input: Request | string, options: Request | RequestInit) {\n    if (input instanceof Request) {\n      if (input.bodyInit && input.bodyUsed) {\n        throw new TypeError(\"Already read\");\n      }\n      super(input.body);\n\n      this.url = input.url;\n      this.method = input.method;\n      this.headers = new Headers(options.headers ?? input.headers);\n\n      if (input.bodyInit) {\n        input._consumed = true;\n      }\n    } else {\n      if (options instanceof Request) {\n        if (options.bodyInit && options.bodyUsed) {\n          throw new TypeError(\"Already read\");\n        }\n        super(options.body);\n\n        if (options.bodyInit) {\n          options._consumed = true;\n        }\n      } else {\n        super(options.body ?? null);\n      }\n      this.url = input;\n      this.method = options.method || \"GET\";\n      this.headers = this.headers ?? new Headers(options.headers);\n    }\n\n    if (this.bodyInit && [\"GET\", \"HEAD\"].includes(this.method)) {\n      throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n    }\n\n    if (this.bodyInit) {\n      if (!this.headers.has(\"content-type\") && this._mimeType) {\n        this.headers.set(\"content-type\", this._mimeType);\n      }\n    }\n  }\n\n  clone() {\n    return new Request(this, { body: this.bodyInit });\n  }\n}\n","import Body, { BodyInit } from \"./Body\";\nimport Headers, { HeadersInit } from \"./Headers\";\n\nexport interface ResponseInit {\n  status?: number;\n  statusText?: string;\n  headers?: HeadersInit;\n}\n\nexport default class Response extends Body {\n  readonly ok: boolean;\n  readonly status: number;\n  readonly statusText: string;\n  readonly headers: Headers;\n  readonly url: string;\n\n  constructor(body: BodyInit | null, options: ResponseInit | Response) {\n    super(body);\n    this.status = options.status ?? 200;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = options.statusText ?? \"\";\n    this.headers = new Headers(options.headers);\n\n    if (options instanceof Response) {\n      this.url = options.url;\n    } else {\n      this.url = \"\";\n    }\n\n    if (!this.headers.has(\"content-type\") && this._mimeType) {\n      this.headers.set(\"content-type\", this._mimeType);\n    }\n  }\n\n  clone() {\n    return new Response(this.bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url,\n    });\n  }\n\n  static redirect(url: string, status: number) {\n    const redirectStatuses = [301, 302, 303, 307, 308];\n\n    if (!redirectStatuses.includes(status)) {\n      throw new RangeError(`Invalid status code: ${status}`);\n    }\n\n    return new Response(null, { status: status, headers: { location: url } });\n  }\n}\n","import { globals } from \"./utils\";\nimport Headers from \"./Headers\";\nimport Request from \"./Request\";\nimport Response from \"./Response\";\n\nconst m = {\n  Headers,\n  Request,\n  Response,\n};\n\n// Add classes to global scope\nif (typeof globals !== \"undefined\") {\n  for (const prop in m) {\n    if (Object.prototype.hasOwnProperty.call(m, prop)) {\n      Object.defineProperty(globals, prop, {\n        value: m[prop as keyof typeof m],\n        writable: true,\n        configurable: true,\n      });\n    }\n  }\n}\n"],"names":["async","drainStream","stream","chunks","reader","getReader","bytes","readNextChunk","done","value","read","reduce","chunk","push","Uint8Array","readArrayBufferAsText","array","TextDecoder","decode","globals","getGlobals","self","window","globalThis","normalizeName","name","String","trim","length","TypeError","test","toLowerCase","normalizeValue","Headers","constructor","init","this","map","Map","forEach","append","Array","isArray","oldValue","get","set","delete","_a","has","callback","thisArg","call","keys","values","entries","Symbol","iterator","Body","body","bodyInit","URLSearchParams","_bodyText","toString","_mimeType","ArrayBuffer","_bodyArrayBuffer","slice","isView","buffer","ReadableStream","_bodyReadableStream","__consumed","_consumed","Promise","reject","alreadyConsumed","byteOffset","byteLength","resolve","text","TextEncoder","encode","JSON","parse","typedArray","start","controller","enqueue","close","encoder","bodyUsed","Request","input","options","super","url","method","headers","_b","_c","includes","clone","Response","status","ok","statusText","static","RangeError","location","m","prop","Object","prototype","hasOwnProperty","defineProperty","writable","configurable"],"mappings":"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"}
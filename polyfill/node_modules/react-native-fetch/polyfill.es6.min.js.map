{"version":3,"file":"polyfill.es6.min.js","sources":["../../../js/src/react-native-fetch/utils.ts","../../../js/src/react-native-fetch/Headers.ts","../../../js/src/react-native-fetch/Body.ts","../../../js/src/react-native-fetch/Request.ts","../../../js/src/react-native-fetch/Response.ts","../../../js/src/react-native-fetch/polyfill.ts"],"sourcesContent":["function getGlobals() {\n  if (typeof self !== \"undefined\") {\n    return self;\n  } else if (typeof window !== \"undefined\") {\n    return window;\n  } else if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  return undefined;\n}\n\nasync function drainStream(stream: ReadableStream<any>): Promise<Uint8Array> {\n  const chunks: any[] = [];\n  const reader = stream.getReader();\n\n  async function readNextChunk(): Promise<any> {\n    const { done, value } = await reader.read();\n    if (done) {\n      return chunks.reduce((bytes, chunk) => [...bytes, ...chunk], []);\n    }\n    chunks.push(value);\n    return readNextChunk();\n  }\n\n  const bytes = await readNextChunk();\n\n  return new Uint8Array(bytes);\n}\n\nfunction readArrayBufferAsText(array: ArrayBuffer) {\n  const decoder = new TextDecoder();\n\n  return decoder.decode(array);\n}\n\nexport { drainStream, readArrayBufferAsText };\n\nexport const globals = getGlobals();\n","function normalizeName(name: string) {\n  if (typeof name !== \"string\") {\n    name = String(name);\n  }\n\n  name = name.trim();\n\n  if (name.length === 0) {\n    throw new TypeError(\"Header field name is empty\");\n  }\n\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name)) {\n    throw new TypeError(`Invalid character in header field name: ${name}`);\n  }\n\n  return name.toLowerCase();\n}\n\nfunction normalizeValue(value: string | number) {\n  if (typeof value !== \"string\") {\n    value = String(value);\n  }\n  return value;\n}\n\nfunction iteratorFor<R = any>(items: R[]): IterableIterator<R> {\n  var dummyR: R;\n  var iterator = {\n    next(): IteratorResult<R> {\n      var value = items.shift();\n      return { done: value === undefined, value: value ?? dummyR };\n    },\n    [Symbol.iterator]() {\n      return iterator;\n    },\n  };\n\n  return iterator;\n}\n\nexport type HeadersInit =\n  | Headers\n  | Record<string, string>\n  | [key: string, value: string][];\n\nexport default class Headers {\n  map: Record<string, string> = {};\n\n  constructor(init?: HeadersInit) {\n    if (init instanceof Headers) {\n      init.forEach((value: string, name: string) => {\n        this.append(name, value);\n      });\n\n      return this;\n    }\n\n    if (Array.isArray(init)) {\n      init.forEach(([name, value]) => {\n        this.append(name, value);\n      });\n\n      return this;\n    }\n\n    if (init) {\n      for (const name in init) {\n        this.append(name, init[name]);\n      }\n    }\n  }\n\n  append(name: string, value: string): void {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    const oldValue = this.map[name];\n    // From MDN: If the specified header already exists and accepts multiple values, append() will append the new value to the end of the value set.\n    // However, we're a missing a check on whether the header does indeed accept multiple values\n    this.map[name] = oldValue ? oldValue + \", \" + value : value;\n  }\n\n  get(name: string): string | null {\n    name = normalizeName(name);\n    return this.map[name] ?? null;\n  }\n\n  has(name: string): boolean {\n    return this.map.hasOwnProperty(normalizeName(name));\n  }\n\n  set(name: string, value: string | number): void {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  }\n\n  forEach(\n    callback: (value: string, key: string, parent?: object) => void,\n    thisArg?: object\n  ): void {\n    for (const key in this.map) {\n      callback.call(thisArg, this.map[key], key, this);\n    }\n  }\n\n  keys(): IterableIterator<string> {\n    return iteratorFor(Object.keys(this.map));\n  }\n\n  values(): IterableIterator<string> {\n    return iteratorFor(Object.values(this.map));\n  }\n\n  entries(): IterableIterator<[string, string]> {\n    var items: [string, string][] = [];\n    this.forEach((value, name) => {\n      items.push([name, value]);\n    });\n    return iteratorFor(items);\n  }\n\n  [Symbol.iterator](): IterableIterator<[string, string]> {\n    return this.entries();\n  }\n}\n","import { drainStream, readArrayBufferAsText } from \"./utils\";\n\nexport type BodyInit = URLSearchParams | ArrayBuffer | ReadableStream | string;\n\nexport default abstract class Body {\n  readonly bodyInit: BodyInit | null;\n  _mimeType?: string;\n  _bodyText: string;\n  _bodyArrayBuffer: ArrayBuffer;\n  _bodyReadableStream: ReadableStream;\n  _consumed: boolean;\n\n  constructor(body: BodyInit | null) {\n    this.bodyInit = body;\n\n    if (body instanceof URLSearchParams) {\n      // URLSearchParams is not handled natively so we reassign bodyInit for fetch to send it as text\n      this._bodyText = this.bodyInit = body.toString();\n      this._mimeType = \"application/x-www-form-urlencoded;charset=UTF-8\";\n      return this;\n    }\n\n    if (body instanceof ArrayBuffer) {\n      this._bodyArrayBuffer = body.slice(0);\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (ArrayBuffer.isView(body)) {\n      this._bodyArrayBuffer = body.buffer;\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (body instanceof ReadableStream) {\n      this._bodyReadableStream = body;\n      this._mimeType = \"application/octet-stream\";\n      return this;\n    }\n\n    if (body) {\n      this._bodyText = body.toString();\n      this._mimeType = \"text/plain;charset=UTF-8\";\n    }\n  }\n\n  __consumed() {\n    if (this._consumed) {\n      return Promise.reject(new TypeError(\"Already read\"));\n    }\n    this._consumed = true;\n  }\n\n  async arrayBuffer() {\n    const alreadyConsumed = this.__consumed();\n    if (alreadyConsumed) {\n      return alreadyConsumed;\n    }\n\n    if (this._bodyReadableStream) {\n      const typedArray = await drainStream(this._bodyReadableStream);\n\n      return typedArray.buffer;\n    }\n\n    if (this._bodyArrayBuffer) {\n      if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n        const { buffer, byteOffset, byteLength } = this._bodyArrayBuffer;\n\n        return Promise.resolve(\n          buffer.slice(byteOffset, byteOffset + byteLength)\n        );\n      }\n\n      return Promise.resolve(this._bodyArrayBuffer);\n    }\n\n    const text = this._bodyText;\n    const encoder = new TextEncoder();\n\n    return encoder.encode(text);\n  }\n\n  async text() {\n    const alreadyConsumed = this.__consumed();\n    if (alreadyConsumed) {\n      return alreadyConsumed;\n    }\n\n    if (this._bodyReadableStream) {\n      const typedArray = await drainStream(this._bodyReadableStream);\n\n      return readArrayBufferAsText(typedArray);\n    }\n\n    if (this._bodyArrayBuffer) {\n      return readArrayBufferAsText(this._bodyArrayBuffer);\n    }\n\n    return this._bodyText;\n  }\n\n  async json<T>(): Promise<T> {\n    const text = await this.text();\n\n    return JSON.parse(text);\n  }\n\n  get body(): ReadableStream | null {\n    if (this._bodyReadableStream) {\n      return this._bodyReadableStream;\n    }\n\n    if (this._bodyArrayBuffer) {\n      const typedArray = new Uint8Array(this._bodyArrayBuffer);\n\n      return new ReadableStream({\n        start(controller) {\n          typedArray.forEach((chunk) => {\n            controller.enqueue(chunk);\n          });\n\n          controller.close();\n        },\n      });\n    }\n\n    if (this._bodyText) {\n      const text = this._bodyText;\n      const encoder = new TextEncoder();\n\n      return new ReadableStream({\n        start: async (controller) => {\n          const typedArray = new Uint8Array(encoder.encode(text));\n\n          typedArray.forEach((chunk) => {\n            controller.enqueue(chunk);\n          });\n\n          controller.close();\n        },\n      });\n    }\n\n    return null;\n  }\n\n  get bodyUsed(): boolean {\n    return this._consumed;\n  }\n}\n","import Body, { BodyInit } from \"./Body\";\nimport Headers, { HeadersInit } from \"./Headers\";\n\nexport type Method = \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"OPTIONS\";\n\nexport interface RequestInit {\n  method?: Method;\n  headers?: HeadersInit;\n  body?: BodyInit | null;\n}\n\nexport default class Request extends Body {\n  readonly url: string;\n  readonly headers: Headers;\n  readonly method: Method;\n\n  constructor(input: Request | string, options: Request | RequestInit) {\n    if (input instanceof Request) {\n      if (input.bodyInit && input.bodyUsed) {\n        throw new TypeError(\"Already read\");\n      }\n      super(input.body);\n\n      this.url = input.url;\n      this.method = input.method;\n      this.headers = new Headers(options.headers ?? input.headers);\n\n      if (input.bodyInit) {\n        input._consumed = true;\n      }\n    } else {\n      if (options instanceof Request) {\n        if (options.bodyInit && options.bodyUsed) {\n          throw new TypeError(\"Already read\");\n        }\n        super(options.body);\n\n        if (options.bodyInit) {\n          options._consumed = true;\n        }\n      } else {\n        super(options.body ?? null);\n      }\n      this.url = input;\n      this.method = options.method || \"GET\";\n      this.headers = this.headers ?? new Headers(options.headers);\n    }\n\n    if (this.bodyInit && [\"GET\", \"HEAD\"].includes(this.method)) {\n      throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n    }\n\n    if (this.bodyInit) {\n      if (!this.headers.has(\"content-type\") && this._mimeType) {\n        this.headers.set(\"content-type\", this._mimeType);\n      }\n    }\n  }\n\n  clone() {\n    return new Request(this, { body: this.bodyInit });\n  }\n}\n","import Body, { BodyInit } from \"./Body\";\nimport Headers, { HeadersInit } from \"./Headers\";\n\nexport interface ResponseInit {\n  status?: number;\n  statusText?: string;\n  headers?: HeadersInit;\n}\n\nexport default class Response extends Body {\n  readonly ok: boolean;\n  readonly status: number;\n  readonly statusText: string;\n  readonly headers: Headers;\n  readonly url: string;\n\n  constructor(body: BodyInit | null, options: ResponseInit | Response) {\n    super(body);\n    this.status = options.status ?? 200;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = options.statusText ?? \"\";\n    this.headers = new Headers(options.headers);\n\n    if (options instanceof Response) {\n      this.url = options.url;\n    } else {\n      this.url = \"\";\n    }\n\n    if (!this.headers.has(\"content-type\") && this._mimeType) {\n      this.headers.set(\"content-type\", this._mimeType);\n    }\n  }\n\n  clone() {\n    return new Response(this.bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url,\n    });\n  }\n\n  static redirect(url: string, status: number) {\n    const redirectStatuses = [301, 302, 303, 307, 308];\n\n    if (!redirectStatuses.includes(status)) {\n      throw new RangeError(`Invalid status code: ${status}`);\n    }\n\n    return new Response(null, { status: status, headers: { location: url } });\n  }\n}\n","import { globals } from \"./utils\";\nimport Headers from \"./Headers\";\nimport Request from \"./Request\";\nimport Response from \"./Response\";\n\nconst m = {\n  Headers,\n  Request,\n  Response,\n};\n\n// Add classes to global scope\nif (typeof globals !== \"undefined\") {\n  for (const prop in m) {\n    if (Object.prototype.hasOwnProperty.call(m, prop)) {\n      Object.defineProperty(globals, prop, {\n        value: m[prop as keyof typeof m],\n        writable: true,\n        configurable: true,\n      });\n    }\n  }\n}\n"],"names":["async","drainStream","stream","chunks","reader","getReader","bytes","readNextChunk","done","value","read","reduce","chunk","push","Uint8Array","readArrayBufferAsText","array","TextDecoder","decode","globals","getGlobals","self","window","globalThis","normalizeName","name","String","trim","length","TypeError","test","toLowerCase","normalizeValue","iteratorFor","items","iterator","next","shift","undefined","dummyR","Symbol","Headers","constructor","init","this","map","forEach","append","Array","isArray","oldValue","get","_a","has","hasOwnProperty","set","callback","thisArg","key","call","keys","Object","values","entries","Body","body","bodyInit","URLSearchParams","_bodyText","toString","_mimeType","ArrayBuffer","_bodyArrayBuffer","slice","isView","buffer","ReadableStream","_bodyReadableStream","__consumed","_consumed","Promise","reject","alreadyConsumed","byteOffset","byteLength","resolve","text","TextEncoder","encode","JSON","parse","typedArray","start","controller","enqueue","close","encoder","bodyUsed","Request","input","options","super","url","method","headers","_b","_c","includes","clone","Response","status","ok","statusText","static","RangeError","location","m","prop","prototype","defineProperty","writable","configurable"],"mappings":"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"}
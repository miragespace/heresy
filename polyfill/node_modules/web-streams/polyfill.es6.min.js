!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?factory(exports):"function"==typeof define&&define.amd?define(["exports"],factory):factory((global="undefined"!=typeof globalThis?globalThis:global||self).WebStreamsPolyfill={})}(this,(function(exports){"use strict";function noop(){}const globals=function getGlobals(){return"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:void 0}();function typeIsObject(x){return"object"==typeof x&&null!==x||"function"==typeof x}const rethrowAssertionErrorRejection=noop,originalPromise=Promise,originalPromiseThen=Promise.prototype.then,originalPromiseResolve=Promise.resolve.bind(originalPromise),originalPromiseReject=Promise.reject.bind(originalPromise);function newPromise(executor){return new originalPromise(executor)}function promiseResolvedWith(value){return originalPromiseResolve(value)}function promiseRejectedWith(reason){return originalPromiseReject(reason)}function PerformPromiseThen(promise,onFulfilled,onRejected){return originalPromiseThen.call(promise,onFulfilled,onRejected)}function uponPromise(promise,onFulfilled,onRejected){PerformPromiseThen(PerformPromiseThen(promise,onFulfilled,onRejected),void 0,rethrowAssertionErrorRejection)}function uponFulfillment(promise,onFulfilled){uponPromise(promise,onFulfilled)}function uponRejection(promise,onRejected){uponPromise(promise,void 0,onRejected)}function transformPromiseWith(promise,fulfillmentHandler,rejectionHandler){return PerformPromiseThen(promise,fulfillmentHandler,rejectionHandler)}function setPromiseIsHandledToTrue(promise){PerformPromiseThen(promise,void 0,rethrowAssertionErrorRejection)}const queueMicrotask=(()=>{const globalQueueMicrotask=globals&&globals.queueMicrotask;if("function"==typeof globalQueueMicrotask)return globalQueueMicrotask;const resolvedPromise=promiseResolvedWith(void 0);return fn=>PerformPromiseThen(resolvedPromise,fn)})();function reflectCall(F,V,args){if("function"!=typeof F)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(F,V,args)}function promiseCall(F,V,args){try{return promiseResolvedWith(reflectCall(F,V,args))}catch(value){return promiseRejectedWith(value)}}class SimpleQueue{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(element){const oldBack=this._back;let newBack=oldBack;16383===oldBack._elements.length&&(newBack={_elements:[],_next:void 0}),oldBack._elements.push(element),newBack!==oldBack&&(this._back=newBack,oldBack._next=newBack),++this._size}shift(){const oldFront=this._front;let newFront=oldFront;const oldCursor=this._cursor;let newCursor=oldCursor+1;const elements=oldFront._elements,element=elements[oldCursor];return 16384===newCursor&&(newFront=oldFront._next,newCursor=0),--this._size,this._cursor=newCursor,oldFront!==newFront&&(this._front=newFront),elements[oldCursor]=void 0,element}forEach(callback){let i=this._cursor,node=this._front,elements=node._elements;for(;!(i===elements.length&&void 0===node._next||i===elements.length&&(node=node._next,elements=node._elements,i=0,0===elements.length));)callback(elements[i]),++i}peek(){const front=this._front,cursor=this._cursor;return front._elements[cursor]}}function ReadableStreamReaderGenericInitialize(reader,stream){reader._ownerReadableStream=stream,stream._reader=reader,"readable"===stream._state?defaultReaderClosedPromiseInitialize(reader):"closed"===stream._state?function defaultReaderClosedPromiseInitializeAsResolved(reader){defaultReaderClosedPromiseInitialize(reader),defaultReaderClosedPromiseResolve(reader)}(reader):defaultReaderClosedPromiseInitializeAsRejected(reader,stream._storedError)}function ReadableStreamReaderGenericCancel(reader,reason){return ReadableStreamCancel(reader._ownerReadableStream,reason)}function ReadableStreamReaderGenericRelease(reader){"readable"===reader._ownerReadableStream._state?defaultReaderClosedPromiseReject(reader,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function defaultReaderClosedPromiseResetToRejected(reader,reason){defaultReaderClosedPromiseInitializeAsRejected(reader,reason)}(reader,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),reader._ownerReadableStream._reader=void 0,reader._ownerReadableStream=void 0}function readerLockException(name){return new TypeError("Cannot "+name+" a stream using a released reader")}function defaultReaderClosedPromiseInitialize(reader){reader._closedPromise=newPromise(((resolve,reject)=>{reader._closedPromise_resolve=resolve,reader._closedPromise_reject=reject}))}function defaultReaderClosedPromiseInitializeAsRejected(reader,reason){defaultReaderClosedPromiseInitialize(reader),defaultReaderClosedPromiseReject(reader,reason)}function defaultReaderClosedPromiseReject(reader,reason){void 0!==reader._closedPromise_reject&&(setPromiseIsHandledToTrue(reader._closedPromise),reader._closedPromise_reject(reason),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0)}function defaultReaderClosedPromiseResolve(reader){void 0!==reader._closedPromise_resolve&&(reader._closedPromise_resolve(void 0),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0)}const AbortSteps=Symbol("[[AbortSteps]]"),ErrorSteps=Symbol("[[ErrorSteps]]"),CancelSteps=Symbol("[[CancelSteps]]"),PullSteps=Symbol("[[PullSteps]]"),NumberIsFinite=Number.isFinite||function(x){return"number"==typeof x&&isFinite(x)},MathTrunc=Math.trunc||function(v){return v<0?Math.ceil(v):Math.floor(v)};function assertDictionary(obj,context){if(void 0!==obj&&!function isDictionary(x){return"object"==typeof x||"function"==typeof x}(obj))throw new TypeError(`${context} is not an object.`)}function assertFunction(x,context){if("function"!=typeof x)throw new TypeError(`${context} is not a function.`)}function assertObject(x,context){if(!function isObject(x){return"object"==typeof x&&null!==x||"function"==typeof x}(x))throw new TypeError(`${context} is not an object.`)}function assertRequiredArgument(x,position,context){if(void 0===x)throw new TypeError(`Parameter ${position} is required in '${context}'.`)}function assertRequiredField(x,field,context){if(void 0===x)throw new TypeError(`${field} is required in '${context}'.`)}function convertUnrestrictedDouble(value){return Number(value)}function censorNegativeZero(x){return 0===x?0:x}function convertUnsignedLongLongWithEnforceRange(value,context){const upperBound=Number.MAX_SAFE_INTEGER;let x=Number(value);if(x=censorNegativeZero(x),!NumberIsFinite(x))throw new TypeError(`${context} is not a finite number`);if(x=function integerPart(x){return censorNegativeZero(MathTrunc(x))}(x),x<0||x>upperBound)throw new TypeError(`${context} is outside the accepted range of 0 to ${upperBound}, inclusive`);return NumberIsFinite(x)&&0!==x?x:0}function assertReadableStream(x,context){if(!IsReadableStream(x))throw new TypeError(`${context} is not a ReadableStream.`)}function AcquireReadableStreamDefaultReader(stream){return new ReadableStreamDefaultReader(stream)}function ReadableStreamAddReadRequest(stream,readRequest){stream._reader._readRequests.push(readRequest)}function ReadableStreamFulfillReadRequest(stream,chunk,done){const readRequest=stream._reader._readRequests.shift();done?readRequest._closeSteps():readRequest._chunkSteps(chunk)}function ReadableStreamGetNumReadRequests(stream){return stream._reader._readRequests.length}function ReadableStreamHasDefaultReader(stream){const reader=stream._reader;return void 0!==reader&&!!IsReadableStreamDefaultReader(reader)}class ReadableStreamDefaultReader{constructor(stream){if(assertRequiredArgument(stream,1,"ReadableStreamDefaultReader"),assertReadableStream(stream,"First parameter"),IsReadableStreamLocked(stream))throw new TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,stream),this._readRequests=new SimpleQueue}get closed(){return IsReadableStreamDefaultReader(this)?this._closedPromise:promiseRejectedWith(defaultReaderBrandCheckException("closed"))}cancel(reason=undefined){return IsReadableStreamDefaultReader(this)?void 0===this._ownerReadableStream?promiseRejectedWith(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,reason):promiseRejectedWith(defaultReaderBrandCheckException("cancel"))}read(){if(!IsReadableStreamDefaultReader(this))return promiseRejectedWith(defaultReaderBrandCheckException("read"));if(void 0===this._ownerReadableStream)return promiseRejectedWith(readerLockException("read from"));let resolvePromise,rejectPromise;const promise=newPromise(((resolve,reject)=>{resolvePromise=resolve,rejectPromise=reject}));return ReadableStreamDefaultReaderRead(this,{_chunkSteps:chunk=>resolvePromise({value:chunk,done:!1}),_closeSteps:()=>resolvePromise({value:void 0,done:!0}),_errorSteps:e=>rejectPromise(e)}),promise}releaseLock(){if(!IsReadableStreamDefaultReader(this))throw defaultReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}}function IsReadableStreamDefaultReader(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_readRequests")&&x instanceof ReadableStreamDefaultReader)}function ReadableStreamDefaultReaderRead(reader,readRequest){const stream=reader._ownerReadableStream;stream._disturbed=!0,"closed"===stream._state?readRequest._closeSteps():"errored"===stream._state?readRequest._errorSteps(stream._storedError):stream._readableStreamController[PullSteps](readRequest)}function defaultReaderBrandCheckException(name){return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`)}let AsyncIteratorPrototype;Object.defineProperties(ReadableStreamDefaultReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableStreamDefaultReader.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0}),"symbol"==typeof Symbol.asyncIterator&&(AsyncIteratorPrototype={[Symbol.asyncIterator](){return this}},Object.defineProperty(AsyncIteratorPrototype,Symbol.asyncIterator,{enumerable:!1}));class ReadableStreamAsyncIteratorImpl{constructor(reader,preventCancel){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=reader,this._preventCancel=preventCancel}next(){const nextSteps=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?transformPromiseWith(this._ongoingPromise,nextSteps,nextSteps):nextSteps(),this._ongoingPromise}return(value){const returnSteps=()=>this._returnSteps(value);return this._ongoingPromise?transformPromiseWith(this._ongoingPromise,returnSteps,returnSteps):returnSteps()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const reader=this._reader;if(void 0===reader._ownerReadableStream)return promiseRejectedWith(readerLockException("iterate"));let resolvePromise,rejectPromise;const promise=newPromise(((resolve,reject)=>{resolvePromise=resolve,rejectPromise=reject}));return ReadableStreamDefaultReaderRead(reader,{_chunkSteps:chunk=>{this._ongoingPromise=void 0,queueMicrotask((()=>resolvePromise({value:chunk,done:!1})))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,ReadableStreamReaderGenericRelease(reader),resolvePromise({value:void 0,done:!0})},_errorSteps:reason=>{this._ongoingPromise=void 0,this._isFinished=!0,ReadableStreamReaderGenericRelease(reader),rejectPromise(reason)}}),promise}_returnSteps(value){if(this._isFinished)return Promise.resolve({value:value,done:!0});this._isFinished=!0;const reader=this._reader;if(void 0===reader._ownerReadableStream)return promiseRejectedWith(readerLockException("finish iterating"));if(!this._preventCancel){const result=ReadableStreamReaderGenericCancel(reader,value);return ReadableStreamReaderGenericRelease(reader),transformPromiseWith(result,(()=>({value:value,done:!0})))}return ReadableStreamReaderGenericRelease(reader),promiseResolvedWith({value:value,done:!0})}}const ReadableStreamAsyncIteratorPrototype={next(){return IsReadableStreamAsyncIterator(this)?this._asyncIteratorImpl.next():promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"))},return(value){return IsReadableStreamAsyncIterator(this)?this._asyncIteratorImpl.return(value):promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"))}};function IsReadableStreamAsyncIterator(x){if(!typeIsObject(x))return!1;if(!Object.prototype.hasOwnProperty.call(x,"_asyncIteratorImpl"))return!1;try{return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl}catch(_a){return!1}}function streamAsyncIteratorBrandCheckException(name){return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`)}void 0!==AsyncIteratorPrototype&&Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype,AsyncIteratorPrototype);const NumberIsNaN=Number.isNaN||function(x){return x!=x};function CreateArrayFromList(elements){return elements.slice()}function CopyDataBlockBytes(dest,destOffset,src,srcOffset,n){new Uint8Array(dest).set(new Uint8Array(src,srcOffset,n),destOffset)}function ArrayBufferSlice(buffer,begin,end){if(buffer.slice)return buffer.slice(begin,end);const length=end-begin,slice=new ArrayBuffer(length);return CopyDataBlockBytes(slice,0,buffer,begin,length),slice}function CloneAsUint8Array(O){const buffer=ArrayBufferSlice(O.buffer,O.byteOffset,O.byteOffset+O.byteLength);return new Uint8Array(buffer)}function DequeueValue(container){const pair=container._queue.shift();return container._queueTotalSize-=pair.size,container._queueTotalSize<0&&(container._queueTotalSize=0),pair.value}function EnqueueValueWithSize(container,value,size){if(!function IsNonNegativeNumber(v){return!("number"!=typeof v||NumberIsNaN(v)||v<0)}(size)||size===1/0)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");container._queue.push({value:value,size:size}),container._queueTotalSize+=size}function ResetQueue(container){container._queue=new SimpleQueue,container._queueTotalSize=0}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("view");return this._view}respond(bytesWritten){if(!IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respond");if(assertRequiredArgument(bytesWritten,1,"respond"),bytesWritten=convertUnsignedLongLongWithEnforceRange(bytesWritten,"First parameter"),void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");this._view.buffer,ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController,bytesWritten)}respondWithNewView(view){if(!IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respondWithNewView");if(assertRequiredArgument(view,1,"respondWithNewView"),!ArrayBuffer.isView(view))throw new TypeError("You can only respond with array buffer views");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");view.buffer,ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController,view)}}Object.defineProperties(ReadableStreamBYOBRequest.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableStreamBYOBRequest.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class ReadableByteStreamController{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("byobRequest");return ReadableByteStreamControllerGetBYOBRequest(this)}get desiredSize(){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("desiredSize");return ReadableByteStreamControllerGetDesiredSize(this)}close(){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const state=this._controlledReadableByteStream._state;if("readable"!==state)throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);ReadableByteStreamControllerClose(this)}enqueue(chunk){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("enqueue");if(assertRequiredArgument(chunk,1,"enqueue"),!ArrayBuffer.isView(chunk))throw new TypeError("chunk must be an array buffer view");if(0===chunk.byteLength)throw new TypeError("chunk must have non-zero byteLength");if(0===chunk.buffer.byteLength)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const state=this._controlledReadableByteStream._state;if("readable"!==state)throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);ReadableByteStreamControllerEnqueue(this,chunk)}error(e=undefined){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("error");ReadableByteStreamControllerError(this,e)}[CancelSteps](reason){ReadableByteStreamControllerClearPendingPullIntos(this),ResetQueue(this);const result=this._cancelAlgorithm(reason);return ReadableByteStreamControllerClearAlgorithms(this),result}[PullSteps](readRequest){const stream=this._controlledReadableByteStream;if(this._queueTotalSize>0){const entry=this._queue.shift();this._queueTotalSize-=entry.byteLength,ReadableByteStreamControllerHandleQueueDrain(this);const view=new Uint8Array(entry.buffer,entry.byteOffset,entry.byteLength);return void readRequest._chunkSteps(view)}const autoAllocateChunkSize=this._autoAllocateChunkSize;if(void 0!==autoAllocateChunkSize){let buffer;try{buffer=new ArrayBuffer(autoAllocateChunkSize)}catch(bufferE){return void readRequest._errorSteps(bufferE)}const pullIntoDescriptor={buffer:buffer,bufferByteLength:autoAllocateChunkSize,byteOffset:0,byteLength:autoAllocateChunkSize,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(pullIntoDescriptor)}ReadableStreamAddReadRequest(stream,readRequest),ReadableByteStreamControllerCallPullIfNeeded(this)}}function IsReadableByteStreamController(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_controlledReadableByteStream")&&x instanceof ReadableByteStreamController)}function IsReadableStreamBYOBRequest(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_associatedReadableByteStreamController")&&x instanceof ReadableStreamBYOBRequest)}function ReadableByteStreamControllerCallPullIfNeeded(controller){const shouldPull=function ReadableByteStreamControllerShouldCallPull(controller){const stream=controller._controlledReadableByteStream;if("readable"!==stream._state)return!1;if(controller._closeRequested)return!1;if(!controller._started)return!1;if(ReadableStreamHasDefaultReader(stream)&&ReadableStreamGetNumReadRequests(stream)>0)return!0;if(ReadableStreamHasBYOBReader(stream)&&ReadableStreamGetNumReadIntoRequests(stream)>0)return!0;const desiredSize=ReadableByteStreamControllerGetDesiredSize(controller);if(desiredSize>0)return!0;return!1}(controller);if(!shouldPull)return;if(controller._pulling)return void(controller._pullAgain=!0);controller._pulling=!0;uponPromise(controller._pullAlgorithm(),(()=>{controller._pulling=!1,controller._pullAgain&&(controller._pullAgain=!1,ReadableByteStreamControllerCallPullIfNeeded(controller))}),(e=>{ReadableByteStreamControllerError(controller,e)}))}function ReadableByteStreamControllerClearPendingPullIntos(controller){ReadableByteStreamControllerInvalidateBYOBRequest(controller),controller._pendingPullIntos=new SimpleQueue}function ReadableByteStreamControllerCommitPullIntoDescriptor(stream,pullIntoDescriptor){let done=!1;"closed"===stream._state&&(done=!0);const filledView=ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);"default"===pullIntoDescriptor.readerType?ReadableStreamFulfillReadRequest(stream,filledView,done):function ReadableStreamFulfillReadIntoRequest(stream,chunk,done){const reader=stream._reader,readIntoRequest=reader._readIntoRequests.shift();done?readIntoRequest._closeSteps(chunk):readIntoRequest._chunkSteps(chunk)}(stream,filledView,done)}function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor){const bytesFilled=pullIntoDescriptor.bytesFilled,elementSize=pullIntoDescriptor.elementSize;return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer,pullIntoDescriptor.byteOffset,bytesFilled/elementSize)}function ReadableByteStreamControllerEnqueueChunkToQueue(controller,buffer,byteOffset,byteLength){controller._queue.push({buffer:buffer,byteOffset:byteOffset,byteLength:byteLength}),controller._queueTotalSize+=byteLength}function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor){const elementSize=pullIntoDescriptor.elementSize,currentAlignedBytes=pullIntoDescriptor.bytesFilled-pullIntoDescriptor.bytesFilled%elementSize,maxBytesToCopy=Math.min(controller._queueTotalSize,pullIntoDescriptor.byteLength-pullIntoDescriptor.bytesFilled),maxBytesFilled=pullIntoDescriptor.bytesFilled+maxBytesToCopy,maxAlignedBytes=maxBytesFilled-maxBytesFilled%elementSize;let totalBytesToCopyRemaining=maxBytesToCopy,ready=!1;maxAlignedBytes>currentAlignedBytes&&(totalBytesToCopyRemaining=maxAlignedBytes-pullIntoDescriptor.bytesFilled,ready=!0);const queue=controller._queue;for(;totalBytesToCopyRemaining>0;){const headOfQueue=queue.peek(),bytesToCopy=Math.min(totalBytesToCopyRemaining,headOfQueue.byteLength),destStart=pullIntoDescriptor.byteOffset+pullIntoDescriptor.bytesFilled;CopyDataBlockBytes(pullIntoDescriptor.buffer,destStart,headOfQueue.buffer,headOfQueue.byteOffset,bytesToCopy),headOfQueue.byteLength===bytesToCopy?queue.shift():(headOfQueue.byteOffset+=bytesToCopy,headOfQueue.byteLength-=bytesToCopy),controller._queueTotalSize-=bytesToCopy,ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller,bytesToCopy,pullIntoDescriptor),totalBytesToCopyRemaining-=bytesToCopy}return ready}function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller,size,pullIntoDescriptor){pullIntoDescriptor.bytesFilled+=size}function ReadableByteStreamControllerHandleQueueDrain(controller){0===controller._queueTotalSize&&controller._closeRequested?(ReadableByteStreamControllerClearAlgorithms(controller),ReadableStreamClose(controller._controlledReadableByteStream)):ReadableByteStreamControllerCallPullIfNeeded(controller)}function ReadableByteStreamControllerInvalidateBYOBRequest(controller){null!==controller._byobRequest&&(controller._byobRequest._associatedReadableByteStreamController=void 0,controller._byobRequest._view=null,controller._byobRequest=null)}function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller){for(;controller._pendingPullIntos.length>0;){if(0===controller._queueTotalSize)return;const pullIntoDescriptor=controller._pendingPullIntos.peek();ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor)&&(ReadableByteStreamControllerShiftPendingPullInto(controller),ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream,pullIntoDescriptor))}}function ReadableByteStreamControllerRespondInternal(controller,bytesWritten){const firstDescriptor=controller._pendingPullIntos.peek();ReadableByteStreamControllerInvalidateBYOBRequest(controller);"closed"===controller._controlledReadableByteStream._state?function ReadableByteStreamControllerRespondInClosedState(controller,firstDescriptor){const stream=controller._controlledReadableByteStream;if(ReadableStreamHasBYOBReader(stream))for(;ReadableStreamGetNumReadIntoRequests(stream)>0;)ReadableByteStreamControllerCommitPullIntoDescriptor(stream,ReadableByteStreamControllerShiftPendingPullInto(controller))}(controller):function ReadableByteStreamControllerRespondInReadableState(controller,bytesWritten,pullIntoDescriptor){if(ReadableByteStreamControllerFillHeadPullIntoDescriptor(0,bytesWritten,pullIntoDescriptor),pullIntoDescriptor.bytesFilled<pullIntoDescriptor.elementSize)return;ReadableByteStreamControllerShiftPendingPullInto(controller);const remainderSize=pullIntoDescriptor.bytesFilled%pullIntoDescriptor.elementSize;if(remainderSize>0){const end=pullIntoDescriptor.byteOffset+pullIntoDescriptor.bytesFilled,remainder=ArrayBufferSlice(pullIntoDescriptor.buffer,end-remainderSize,end);ReadableByteStreamControllerEnqueueChunkToQueue(controller,remainder,0,remainder.byteLength)}pullIntoDescriptor.bytesFilled-=remainderSize,ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream,pullIntoDescriptor),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)}(controller,bytesWritten,firstDescriptor),ReadableByteStreamControllerCallPullIfNeeded(controller)}function ReadableByteStreamControllerShiftPendingPullInto(controller){return controller._pendingPullIntos.shift()}function ReadableByteStreamControllerClearAlgorithms(controller){controller._pullAlgorithm=void 0,controller._cancelAlgorithm=void 0}function ReadableByteStreamControllerClose(controller){const stream=controller._controlledReadableByteStream;if(!controller._closeRequested&&"readable"===stream._state)if(controller._queueTotalSize>0)controller._closeRequested=!0;else{if(controller._pendingPullIntos.length>0){if(controller._pendingPullIntos.peek().bytesFilled>0){const e=new TypeError("Insufficient bytes to fill elements in the given buffer");throw ReadableByteStreamControllerError(controller,e),e}}ReadableByteStreamControllerClearAlgorithms(controller),ReadableStreamClose(stream)}}function ReadableByteStreamControllerEnqueue(controller,chunk){const stream=controller._controlledReadableByteStream;if(controller._closeRequested||"readable"!==stream._state)return;const buffer=chunk.buffer,byteOffset=chunk.byteOffset,byteLength=chunk.byteLength,transferredBuffer=buffer;if(controller._pendingPullIntos.length>0){const firstPendingPullInto=controller._pendingPullIntos.peek();firstPendingPullInto.buffer,0,firstPendingPullInto.buffer=firstPendingPullInto.buffer}if(ReadableByteStreamControllerInvalidateBYOBRequest(controller),ReadableStreamHasDefaultReader(stream))if(0===ReadableStreamGetNumReadRequests(stream))ReadableByteStreamControllerEnqueueChunkToQueue(controller,transferredBuffer,byteOffset,byteLength);else{controller._pendingPullIntos.length>0&&ReadableByteStreamControllerShiftPendingPullInto(controller);ReadableStreamFulfillReadRequest(stream,new Uint8Array(transferredBuffer,byteOffset,byteLength),!1)}else ReadableStreamHasBYOBReader(stream)?(ReadableByteStreamControllerEnqueueChunkToQueue(controller,transferredBuffer,byteOffset,byteLength),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)):ReadableByteStreamControllerEnqueueChunkToQueue(controller,transferredBuffer,byteOffset,byteLength);ReadableByteStreamControllerCallPullIfNeeded(controller)}function ReadableByteStreamControllerError(controller,e){const stream=controller._controlledReadableByteStream;"readable"===stream._state&&(ReadableByteStreamControllerClearPendingPullIntos(controller),ResetQueue(controller),ReadableByteStreamControllerClearAlgorithms(controller),ReadableStreamError(stream,e))}function ReadableByteStreamControllerGetBYOBRequest(controller){if(null===controller._byobRequest&&controller._pendingPullIntos.length>0){const firstDescriptor=controller._pendingPullIntos.peek(),view=new Uint8Array(firstDescriptor.buffer,firstDescriptor.byteOffset+firstDescriptor.bytesFilled,firstDescriptor.byteLength-firstDescriptor.bytesFilled),byobRequest=Object.create(ReadableStreamBYOBRequest.prototype);!function SetUpReadableStreamBYOBRequest(request,controller,view){request._associatedReadableByteStreamController=controller,request._view=view}(byobRequest,controller,view),controller._byobRequest=byobRequest}return controller._byobRequest}function ReadableByteStreamControllerGetDesiredSize(controller){const state=controller._controlledReadableByteStream._state;return"errored"===state?null:"closed"===state?0:controller._strategyHWM-controller._queueTotalSize}function ReadableByteStreamControllerRespond(controller,bytesWritten){const firstDescriptor=controller._pendingPullIntos.peek();if("closed"===controller._controlledReadableByteStream._state){if(0!==bytesWritten)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(0===bytesWritten)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(firstDescriptor.bytesFilled+bytesWritten>firstDescriptor.byteLength)throw new RangeError("bytesWritten out of range")}firstDescriptor.buffer=firstDescriptor.buffer,ReadableByteStreamControllerRespondInternal(controller,bytesWritten)}function ReadableByteStreamControllerRespondWithNewView(controller,view){const firstDescriptor=controller._pendingPullIntos.peek();if("closed"===controller._controlledReadableByteStream._state){if(0!==view.byteLength)throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(0===view.byteLength)throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(firstDescriptor.byteOffset+firstDescriptor.bytesFilled!==view.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(firstDescriptor.bufferByteLength!==view.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(firstDescriptor.bytesFilled+view.byteLength>firstDescriptor.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");const viewByteLength=view.byteLength;firstDescriptor.buffer=view.buffer,ReadableByteStreamControllerRespondInternal(controller,viewByteLength)}function SetUpReadableByteStreamController(stream,controller,startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark,autoAllocateChunkSize){controller._controlledReadableByteStream=stream,controller._pullAgain=!1,controller._pulling=!1,controller._byobRequest=null,controller._queue=controller._queueTotalSize=void 0,ResetQueue(controller),controller._closeRequested=!1,controller._started=!1,controller._strategyHWM=highWaterMark,controller._pullAlgorithm=pullAlgorithm,controller._cancelAlgorithm=cancelAlgorithm,controller._autoAllocateChunkSize=autoAllocateChunkSize,controller._pendingPullIntos=new SimpleQueue,stream._readableStreamController=controller;uponPromise(promiseResolvedWith(startAlgorithm()),(()=>{controller._started=!0,ReadableByteStreamControllerCallPullIfNeeded(controller)}),(r=>{ReadableByteStreamControllerError(controller,r)}))}function byobRequestBrandCheckException(name){return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`)}function byteStreamControllerBrandCheckException(name){return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`)}function AcquireReadableStreamBYOBReader(stream){return new ReadableStreamBYOBReader(stream)}function ReadableStreamAddReadIntoRequest(stream,readIntoRequest){stream._reader._readIntoRequests.push(readIntoRequest)}function ReadableStreamGetNumReadIntoRequests(stream){return stream._reader._readIntoRequests.length}function ReadableStreamHasBYOBReader(stream){const reader=stream._reader;return void 0!==reader&&!!IsReadableStreamBYOBReader(reader)}Object.defineProperties(ReadableByteStreamController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableByteStreamController.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class ReadableStreamBYOBReader{constructor(stream){if(assertRequiredArgument(stream,1,"ReadableStreamBYOBReader"),assertReadableStream(stream,"First parameter"),IsReadableStreamLocked(stream))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!IsReadableByteStreamController(stream._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");ReadableStreamReaderGenericInitialize(this,stream),this._readIntoRequests=new SimpleQueue}get closed(){return IsReadableStreamBYOBReader(this)?this._closedPromise:promiseRejectedWith(byobReaderBrandCheckException("closed"))}cancel(reason=undefined){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?promiseRejectedWith(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,reason):promiseRejectedWith(byobReaderBrandCheckException("cancel"))}read(view){if(!IsReadableStreamBYOBReader(this))return promiseRejectedWith(byobReaderBrandCheckException("read"));if(!ArrayBuffer.isView(view))return promiseRejectedWith(new TypeError("view must be an array buffer view"));if(0===view.byteLength)return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));if(0===view.buffer.byteLength)return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));if(view.buffer,void 0===this._ownerReadableStream)return promiseRejectedWith(readerLockException("read from"));let resolvePromise,rejectPromise;const promise=newPromise(((resolve,reject)=>{resolvePromise=resolve,rejectPromise=reject}));return ReadableStreamBYOBReaderRead(this,view,{_chunkSteps:chunk=>resolvePromise({value:chunk,done:!1}),_closeSteps:chunk=>resolvePromise({value:chunk,done:!0}),_errorSteps:e=>rejectPromise(e)}),promise}releaseLock(){if(!IsReadableStreamBYOBReader(this))throw byobReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}}function IsReadableStreamBYOBReader(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_readIntoRequests")&&x instanceof ReadableStreamBYOBReader)}function ReadableStreamBYOBReaderRead(reader,view,readIntoRequest){const stream=reader._ownerReadableStream;stream._disturbed=!0,"errored"===stream._state?readIntoRequest._errorSteps(stream._storedError):function ReadableByteStreamControllerPullInto(controller,view,readIntoRequest){const stream=controller._controlledReadableByteStream;let elementSize=1;view.constructor!==DataView&&(elementSize=view.constructor.BYTES_PER_ELEMENT);const ctor=view.constructor,buffer=view.buffer,pullIntoDescriptor={buffer:buffer,bufferByteLength:buffer.byteLength,byteOffset:view.byteOffset,byteLength:view.byteLength,bytesFilled:0,elementSize:elementSize,viewConstructor:ctor,readerType:"byob"};if(controller._pendingPullIntos.length>0)return controller._pendingPullIntos.push(pullIntoDescriptor),void ReadableStreamAddReadIntoRequest(stream,readIntoRequest);if("closed"!==stream._state){if(controller._queueTotalSize>0){if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor)){const filledView=ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);return ReadableByteStreamControllerHandleQueueDrain(controller),void readIntoRequest._chunkSteps(filledView)}if(controller._closeRequested){const e=new TypeError("Insufficient bytes to fill elements in the given buffer");return ReadableByteStreamControllerError(controller,e),void readIntoRequest._errorSteps(e)}}controller._pendingPullIntos.push(pullIntoDescriptor),ReadableStreamAddReadIntoRequest(stream,readIntoRequest),ReadableByteStreamControllerCallPullIfNeeded(controller)}else{const emptyView=new ctor(pullIntoDescriptor.buffer,pullIntoDescriptor.byteOffset,0);readIntoRequest._closeSteps(emptyView)}}(stream._readableStreamController,view,readIntoRequest)}function byobReaderBrandCheckException(name){return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`)}function ExtractHighWaterMark(strategy,defaultHWM){const{highWaterMark:highWaterMark}=strategy;if(void 0===highWaterMark)return defaultHWM;if(NumberIsNaN(highWaterMark)||highWaterMark<0)throw new RangeError("Invalid highWaterMark");return highWaterMark}function ExtractSizeAlgorithm(strategy){const{size:size}=strategy;return size||(()=>1)}function convertQueuingStrategy(init,context){assertDictionary(init,context);const highWaterMark=null==init?void 0:init.highWaterMark,size=null==init?void 0:init.size;return{highWaterMark:void 0===highWaterMark?void 0:convertUnrestrictedDouble(highWaterMark),size:void 0===size?void 0:convertQueuingStrategySize(size,`${context} has member 'size' that`)}}function convertQueuingStrategySize(fn,context){return assertFunction(fn,context),chunk=>convertUnrestrictedDouble(fn(chunk))}function convertUnderlyingSinkAbortCallback(fn,original,context){return assertFunction(fn,context),reason=>promiseCall(fn,original,[reason])}function convertUnderlyingSinkCloseCallback(fn,original,context){return assertFunction(fn,context),()=>promiseCall(fn,original,[])}function convertUnderlyingSinkStartCallback(fn,original,context){return assertFunction(fn,context),controller=>reflectCall(fn,original,[controller])}function convertUnderlyingSinkWriteCallback(fn,original,context){return assertFunction(fn,context),(chunk,controller)=>promiseCall(fn,original,[chunk,controller])}function assertWritableStream(x,context){if(!IsWritableStream(x))throw new TypeError(`${context} is not a WritableStream.`)}Object.defineProperties(ReadableStreamBYOBReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableStreamBYOBReader.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});const supportsAbortController="function"==typeof AbortController;class WritableStream{constructor(rawUnderlyingSink={},rawStrategy={}){void 0===rawUnderlyingSink?rawUnderlyingSink=null:assertObject(rawUnderlyingSink,"First parameter");const strategy=convertQueuingStrategy(rawStrategy,"Second parameter"),underlyingSink=function convertUnderlyingSink(original,context){assertDictionary(original,context);const abort=null==original?void 0:original.abort,close=null==original?void 0:original.close,start=null==original?void 0:original.start,type=null==original?void 0:original.type,write=null==original?void 0:original.write;return{abort:void 0===abort?void 0:convertUnderlyingSinkAbortCallback(abort,original,`${context} has member 'abort' that`),close:void 0===close?void 0:convertUnderlyingSinkCloseCallback(close,original,`${context} has member 'close' that`),start:void 0===start?void 0:convertUnderlyingSinkStartCallback(start,original,`${context} has member 'start' that`),write:void 0===write?void 0:convertUnderlyingSinkWriteCallback(write,original,`${context} has member 'write' that`),type:type}}(rawUnderlyingSink,"First parameter");InitializeWritableStream(this);if(void 0!==underlyingSink.type)throw new RangeError("Invalid type is specified");const sizeAlgorithm=ExtractSizeAlgorithm(strategy);!function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream,underlyingSink,highWaterMark,sizeAlgorithm){const controller=Object.create(WritableStreamDefaultController.prototype);let startAlgorithm=()=>{},writeAlgorithm=()=>promiseResolvedWith(void 0),closeAlgorithm=()=>promiseResolvedWith(void 0),abortAlgorithm=()=>promiseResolvedWith(void 0);void 0!==underlyingSink.start&&(startAlgorithm=()=>underlyingSink.start(controller));void 0!==underlyingSink.write&&(writeAlgorithm=chunk=>underlyingSink.write(chunk,controller));void 0!==underlyingSink.close&&(closeAlgorithm=()=>underlyingSink.close());void 0!==underlyingSink.abort&&(abortAlgorithm=reason=>underlyingSink.abort(reason));SetUpWritableStreamDefaultController(stream,controller,startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,highWaterMark,sizeAlgorithm)}(this,underlyingSink,ExtractHighWaterMark(strategy,1),sizeAlgorithm)}get locked(){if(!IsWritableStream(this))throw streamBrandCheckException$2("locked");return IsWritableStreamLocked(this)}abort(reason=undefined){return IsWritableStream(this)?IsWritableStreamLocked(this)?promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer")):WritableStreamAbort(this,reason):promiseRejectedWith(streamBrandCheckException$2("abort"))}close(){return IsWritableStream(this)?IsWritableStreamLocked(this)?promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer")):WritableStreamCloseQueuedOrInFlight(this)?promiseRejectedWith(new TypeError("Cannot close an already-closing stream")):WritableStreamClose(this):promiseRejectedWith(streamBrandCheckException$2("close"))}getWriter(){if(!IsWritableStream(this))throw streamBrandCheckException$2("getWriter");return AcquireWritableStreamDefaultWriter(this)}}function AcquireWritableStreamDefaultWriter(stream){return new WritableStreamDefaultWriter(stream)}function InitializeWritableStream(stream){stream._state="writable",stream._storedError=void 0,stream._writer=void 0,stream._writableStreamController=void 0,stream._writeRequests=new SimpleQueue,stream._inFlightWriteRequest=void 0,stream._closeRequest=void 0,stream._inFlightCloseRequest=void 0,stream._pendingAbortRequest=void 0,stream._backpressure=!1}function IsWritableStream(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_writableStreamController")&&x instanceof WritableStream)}function IsWritableStreamLocked(stream){return void 0!==stream._writer}function WritableStreamAbort(stream,reason){var _a;if("closed"===stream._state||"errored"===stream._state)return promiseResolvedWith(void 0);stream._writableStreamController._abortReason=reason,null===(_a=stream._writableStreamController._abortController)||void 0===_a||_a.abort();const state=stream._state;if("closed"===state||"errored"===state)return promiseResolvedWith(void 0);if(void 0!==stream._pendingAbortRequest)return stream._pendingAbortRequest._promise;let wasAlreadyErroring=!1;"erroring"===state&&(wasAlreadyErroring=!0,reason=void 0);const promise=newPromise(((resolve,reject)=>{stream._pendingAbortRequest={_promise:void 0,_resolve:resolve,_reject:reject,_reason:reason,_wasAlreadyErroring:wasAlreadyErroring}}));return stream._pendingAbortRequest._promise=promise,wasAlreadyErroring||WritableStreamStartErroring(stream,reason),promise}function WritableStreamClose(stream){const state=stream._state;if("closed"===state||"errored"===state)return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));const promise=newPromise(((resolve,reject)=>{const closeRequest={_resolve:resolve,_reject:reject};stream._closeRequest=closeRequest})),writer=stream._writer;return void 0!==writer&&stream._backpressure&&"writable"===state&&defaultWriterReadyPromiseResolve(writer),function WritableStreamDefaultControllerClose(controller){EnqueueValueWithSize(controller,closeSentinel,0),WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)}(stream._writableStreamController),promise}function WritableStreamDealWithRejection(stream,error){"writable"!==stream._state?WritableStreamFinishErroring(stream):WritableStreamStartErroring(stream,error)}function WritableStreamStartErroring(stream,reason){const controller=stream._writableStreamController;stream._state="erroring",stream._storedError=reason;const writer=stream._writer;void 0!==writer&&WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer,reason),!function WritableStreamHasOperationMarkedInFlight(stream){if(void 0===stream._inFlightWriteRequest&&void 0===stream._inFlightCloseRequest)return!1;return!0}(stream)&&controller._started&&WritableStreamFinishErroring(stream)}function WritableStreamFinishErroring(stream){stream._state="errored",stream._writableStreamController[ErrorSteps]();const storedError=stream._storedError;if(stream._writeRequests.forEach((writeRequest=>{writeRequest._reject(storedError)})),stream._writeRequests=new SimpleQueue,void 0===stream._pendingAbortRequest)return void WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);const abortRequest=stream._pendingAbortRequest;if(stream._pendingAbortRequest=void 0,abortRequest._wasAlreadyErroring)return abortRequest._reject(storedError),void WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);uponPromise(stream._writableStreamController[AbortSteps](abortRequest._reason),(()=>{abortRequest._resolve(),WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream)}),(reason=>{abortRequest._reject(reason),WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream)}))}function WritableStreamCloseQueuedOrInFlight(stream){return void 0!==stream._closeRequest||void 0!==stream._inFlightCloseRequest}function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream){void 0!==stream._closeRequest&&(stream._closeRequest._reject(stream._storedError),stream._closeRequest=void 0);const writer=stream._writer;void 0!==writer&&defaultWriterClosedPromiseReject(writer,stream._storedError)}function WritableStreamUpdateBackpressure(stream,backpressure){const writer=stream._writer;void 0!==writer&&backpressure!==stream._backpressure&&(backpressure?function defaultWriterReadyPromiseReset(writer){defaultWriterReadyPromiseInitialize(writer)}(writer):defaultWriterReadyPromiseResolve(writer)),stream._backpressure=backpressure}Object.defineProperties(WritableStream.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(WritableStream.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:!0});class WritableStreamDefaultWriter{constructor(stream){if(assertRequiredArgument(stream,1,"WritableStreamDefaultWriter"),assertWritableStream(stream,"First parameter"),IsWritableStreamLocked(stream))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=stream,stream._writer=this;const state=stream._state;if("writable"===state)!WritableStreamCloseQueuedOrInFlight(stream)&&stream._backpressure?defaultWriterReadyPromiseInitialize(this):defaultWriterReadyPromiseInitializeAsResolved(this),defaultWriterClosedPromiseInitialize(this);else if("erroring"===state)defaultWriterReadyPromiseInitializeAsRejected(this,stream._storedError),defaultWriterClosedPromiseInitialize(this);else if("closed"===state)defaultWriterReadyPromiseInitializeAsResolved(this),function defaultWriterClosedPromiseInitializeAsResolved(writer){defaultWriterClosedPromiseInitialize(writer),defaultWriterClosedPromiseResolve(writer)}(this);else{const storedError=stream._storedError;defaultWriterReadyPromiseInitializeAsRejected(this,storedError),defaultWriterClosedPromiseInitializeAsRejected(this,storedError)}}get closed(){return IsWritableStreamDefaultWriter(this)?this._closedPromise:promiseRejectedWith(defaultWriterBrandCheckException("closed"))}get desiredSize(){if(!IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("desiredSize");if(void 0===this._ownerWritableStream)throw defaultWriterLockException("desiredSize");return function WritableStreamDefaultWriterGetDesiredSize(writer){const stream=writer._ownerWritableStream,state=stream._state;if("errored"===state||"erroring"===state)return null;if("closed"===state)return 0;return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController)}(this)}get ready(){return IsWritableStreamDefaultWriter(this)?this._readyPromise:promiseRejectedWith(defaultWriterBrandCheckException("ready"))}abort(reason=undefined){return IsWritableStreamDefaultWriter(this)?void 0===this._ownerWritableStream?promiseRejectedWith(defaultWriterLockException("abort")):function WritableStreamDefaultWriterAbort(writer,reason){return WritableStreamAbort(writer._ownerWritableStream,reason)}(this,reason):promiseRejectedWith(defaultWriterBrandCheckException("abort"))}close(){if(!IsWritableStreamDefaultWriter(this))return promiseRejectedWith(defaultWriterBrandCheckException("close"));const stream=this._ownerWritableStream;return void 0===stream?promiseRejectedWith(defaultWriterLockException("close")):WritableStreamCloseQueuedOrInFlight(stream)?promiseRejectedWith(new TypeError("Cannot close an already-closing stream")):WritableStreamDefaultWriterClose(this)}releaseLock(){if(!IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("releaseLock");void 0!==this._ownerWritableStream&&WritableStreamDefaultWriterRelease(this)}write(chunk=undefined){return IsWritableStreamDefaultWriter(this)?void 0===this._ownerWritableStream?promiseRejectedWith(defaultWriterLockException("write to")):WritableStreamDefaultWriterWrite(this,chunk):promiseRejectedWith(defaultWriterBrandCheckException("write"))}}function IsWritableStreamDefaultWriter(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_ownerWritableStream")&&x instanceof WritableStreamDefaultWriter)}function WritableStreamDefaultWriterClose(writer){return WritableStreamClose(writer._ownerWritableStream)}function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer,error){"pending"===writer._closedPromiseState?defaultWriterClosedPromiseReject(writer,error):function defaultWriterClosedPromiseResetToRejected(writer,reason){defaultWriterClosedPromiseInitializeAsRejected(writer,reason)}(writer,error)}function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer,error){"pending"===writer._readyPromiseState?defaultWriterReadyPromiseReject(writer,error):function defaultWriterReadyPromiseResetToRejected(writer,reason){defaultWriterReadyPromiseInitializeAsRejected(writer,reason)}(writer,error)}function WritableStreamDefaultWriterRelease(writer){const stream=writer._ownerWritableStream,releasedError=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer,releasedError),WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer,releasedError),stream._writer=void 0,writer._ownerWritableStream=void 0}function WritableStreamDefaultWriterWrite(writer,chunk){const stream=writer._ownerWritableStream,controller=stream._writableStreamController,chunkSize=function WritableStreamDefaultControllerGetChunkSize(controller,chunk){try{return controller._strategySizeAlgorithm(chunk)}catch(chunkSizeE){return WritableStreamDefaultControllerErrorIfNeeded(controller,chunkSizeE),1}}(controller,chunk);if(stream!==writer._ownerWritableStream)return promiseRejectedWith(defaultWriterLockException("write to"));const state=stream._state;if("errored"===state)return promiseRejectedWith(stream._storedError);if(WritableStreamCloseQueuedOrInFlight(stream)||"closed"===state)return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===state)return promiseRejectedWith(stream._storedError);const promise=function WritableStreamAddWriteRequest(stream){return newPromise(((resolve,reject)=>{const writeRequest={_resolve:resolve,_reject:reject};stream._writeRequests.push(writeRequest)}))}(stream);return function WritableStreamDefaultControllerWrite(controller,chunk,chunkSize){try{EnqueueValueWithSize(controller,chunk,chunkSize)}catch(enqueueE){return void WritableStreamDefaultControllerErrorIfNeeded(controller,enqueueE)}const stream=controller._controlledWritableStream;if(!WritableStreamCloseQueuedOrInFlight(stream)&&"writable"===stream._state){WritableStreamUpdateBackpressure(stream,WritableStreamDefaultControllerGetBackpressure(controller))}WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)}(controller,chunk,chunkSize),promise}Object.defineProperties(WritableStreamDefaultWriter.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(WritableStreamDefaultWriter.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});const closeSentinel={};class WritableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!IsWritableStreamDefaultController(this))throw defaultControllerBrandCheckException$2("abortReason");return this._abortReason}get signal(){if(!IsWritableStreamDefaultController(this))throw defaultControllerBrandCheckException$2("signal");if(void 0===this._abortController)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(e=undefined){if(!IsWritableStreamDefaultController(this))throw defaultControllerBrandCheckException$2("error");"writable"===this._controlledWritableStream._state&&WritableStreamDefaultControllerError(this,e)}[AbortSteps](reason){const result=this._abortAlgorithm(reason);return WritableStreamDefaultControllerClearAlgorithms(this),result}[ErrorSteps](){ResetQueue(this)}}function IsWritableStreamDefaultController(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_controlledWritableStream")&&x instanceof WritableStreamDefaultController)}function SetUpWritableStreamDefaultController(stream,controller,startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,highWaterMark,sizeAlgorithm){controller._controlledWritableStream=stream,stream._writableStreamController=controller,controller._queue=void 0,controller._queueTotalSize=void 0,ResetQueue(controller),controller._abortReason=void 0,controller._abortController=function createAbortController(){if(supportsAbortController)return new AbortController}(),controller._started=!1,controller._strategySizeAlgorithm=sizeAlgorithm,controller._strategyHWM=highWaterMark,controller._writeAlgorithm=writeAlgorithm,controller._closeAlgorithm=closeAlgorithm,controller._abortAlgorithm=abortAlgorithm;const backpressure=WritableStreamDefaultControllerGetBackpressure(controller);WritableStreamUpdateBackpressure(stream,backpressure);uponPromise(promiseResolvedWith(startAlgorithm()),(()=>{controller._started=!0,WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)}),(r=>{controller._started=!0,WritableStreamDealWithRejection(stream,r)}))}function WritableStreamDefaultControllerClearAlgorithms(controller){controller._writeAlgorithm=void 0,controller._closeAlgorithm=void 0,controller._abortAlgorithm=void 0,controller._strategySizeAlgorithm=void 0}function WritableStreamDefaultControllerGetDesiredSize(controller){return controller._strategyHWM-controller._queueTotalSize}function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller){const stream=controller._controlledWritableStream;if(!controller._started)return;if(void 0!==stream._inFlightWriteRequest)return;if("erroring"===stream._state)return void WritableStreamFinishErroring(stream);if(0===controller._queue.length)return;const value=function PeekQueueValue(container){return container._queue.peek().value}(controller);value===closeSentinel?function WritableStreamDefaultControllerProcessClose(controller){const stream=controller._controlledWritableStream;(function WritableStreamMarkCloseRequestInFlight(stream){stream._inFlightCloseRequest=stream._closeRequest,stream._closeRequest=void 0})(stream),DequeueValue(controller);const sinkClosePromise=controller._closeAlgorithm();WritableStreamDefaultControllerClearAlgorithms(controller),uponPromise(sinkClosePromise,(()=>{!function WritableStreamFinishInFlightClose(stream){stream._inFlightCloseRequest._resolve(void 0),stream._inFlightCloseRequest=void 0,"erroring"===stream._state&&(stream._storedError=void 0,void 0!==stream._pendingAbortRequest&&(stream._pendingAbortRequest._resolve(),stream._pendingAbortRequest=void 0)),stream._state="closed";const writer=stream._writer;void 0!==writer&&defaultWriterClosedPromiseResolve(writer)}(stream)}),(reason=>{!function WritableStreamFinishInFlightCloseWithError(stream,error){stream._inFlightCloseRequest._reject(error),stream._inFlightCloseRequest=void 0,void 0!==stream._pendingAbortRequest&&(stream._pendingAbortRequest._reject(error),stream._pendingAbortRequest=void 0),WritableStreamDealWithRejection(stream,error)}(stream,reason)}))}(controller):function WritableStreamDefaultControllerProcessWrite(controller,chunk){const stream=controller._controlledWritableStream;!function WritableStreamMarkFirstWriteRequestInFlight(stream){stream._inFlightWriteRequest=stream._writeRequests.shift()}(stream);const sinkWritePromise=controller._writeAlgorithm(chunk);uponPromise(sinkWritePromise,(()=>{!function WritableStreamFinishInFlightWrite(stream){stream._inFlightWriteRequest._resolve(void 0),stream._inFlightWriteRequest=void 0}(stream);const state=stream._state;if(DequeueValue(controller),!WritableStreamCloseQueuedOrInFlight(stream)&&"writable"===state){const backpressure=WritableStreamDefaultControllerGetBackpressure(controller);WritableStreamUpdateBackpressure(stream,backpressure)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)}),(reason=>{"writable"===stream._state&&WritableStreamDefaultControllerClearAlgorithms(controller),function WritableStreamFinishInFlightWriteWithError(stream,error){stream._inFlightWriteRequest._reject(error),stream._inFlightWriteRequest=void 0,WritableStreamDealWithRejection(stream,error)}(stream,reason)}))}(controller,value)}function WritableStreamDefaultControllerErrorIfNeeded(controller,error){"writable"===controller._controlledWritableStream._state&&WritableStreamDefaultControllerError(controller,error)}function WritableStreamDefaultControllerGetBackpressure(controller){return WritableStreamDefaultControllerGetDesiredSize(controller)<=0}function WritableStreamDefaultControllerError(controller,error){const stream=controller._controlledWritableStream;WritableStreamDefaultControllerClearAlgorithms(controller),WritableStreamStartErroring(stream,error)}function streamBrandCheckException$2(name){return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`)}function defaultControllerBrandCheckException$2(name){return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`)}function defaultWriterBrandCheckException(name){return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`)}function defaultWriterLockException(name){return new TypeError("Cannot "+name+" a stream using a released writer")}function defaultWriterClosedPromiseInitialize(writer){writer._closedPromise=newPromise(((resolve,reject)=>{writer._closedPromise_resolve=resolve,writer._closedPromise_reject=reject,writer._closedPromiseState="pending"}))}function defaultWriterClosedPromiseInitializeAsRejected(writer,reason){defaultWriterClosedPromiseInitialize(writer),defaultWriterClosedPromiseReject(writer,reason)}function defaultWriterClosedPromiseReject(writer,reason){void 0!==writer._closedPromise_reject&&(setPromiseIsHandledToTrue(writer._closedPromise),writer._closedPromise_reject(reason),writer._closedPromise_resolve=void 0,writer._closedPromise_reject=void 0,writer._closedPromiseState="rejected")}function defaultWriterClosedPromiseResolve(writer){void 0!==writer._closedPromise_resolve&&(writer._closedPromise_resolve(void 0),writer._closedPromise_resolve=void 0,writer._closedPromise_reject=void 0,writer._closedPromiseState="resolved")}function defaultWriterReadyPromiseInitialize(writer){writer._readyPromise=newPromise(((resolve,reject)=>{writer._readyPromise_resolve=resolve,writer._readyPromise_reject=reject})),writer._readyPromiseState="pending"}function defaultWriterReadyPromiseInitializeAsRejected(writer,reason){defaultWriterReadyPromiseInitialize(writer),defaultWriterReadyPromiseReject(writer,reason)}function defaultWriterReadyPromiseInitializeAsResolved(writer){defaultWriterReadyPromiseInitialize(writer),defaultWriterReadyPromiseResolve(writer)}function defaultWriterReadyPromiseReject(writer,reason){void 0!==writer._readyPromise_reject&&(setPromiseIsHandledToTrue(writer._readyPromise),writer._readyPromise_reject(reason),writer._readyPromise_resolve=void 0,writer._readyPromise_reject=void 0,writer._readyPromiseState="rejected")}function defaultWriterReadyPromiseResolve(writer){void 0!==writer._readyPromise_resolve&&(writer._readyPromise_resolve(void 0),writer._readyPromise_resolve=void 0,writer._readyPromise_reject=void 0,writer._readyPromiseState="fulfilled")}Object.defineProperties(WritableStreamDefaultController.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(WritableStreamDefaultController.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});const NativeDOMException="undefined"!=typeof DOMException?DOMException:void 0;const DOMException$1=function isDOMExceptionConstructor(ctor){if("function"!=typeof ctor&&"object"!=typeof ctor)return!1;try{return new ctor,!0}catch(_a){return!1}}(NativeDOMException)?NativeDOMException:function createDOMExceptionPolyfill(){const ctor=function DOMException(message,name){this.message=message||"",this.name=name||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return ctor.prototype=Object.create(Error.prototype),Object.defineProperty(ctor.prototype,"constructor",{value:ctor,writable:!0,configurable:!0}),ctor}();function ReadableStreamPipeTo(source,dest,preventClose,preventAbort,preventCancel,signal){const reader=AcquireReadableStreamDefaultReader(source),writer=AcquireWritableStreamDefaultWriter(dest);source._disturbed=!0;let shuttingDown=!1,currentWrite=promiseResolvedWith(void 0);return newPromise(((resolve,reject)=>{let abortAlgorithm;if(void 0!==signal){if(abortAlgorithm=()=>{const error=new DOMException$1("Aborted","AbortError"),actions=[];preventAbort||actions.push((()=>"writable"===dest._state?WritableStreamAbort(dest,error):promiseResolvedWith(void 0))),preventCancel||actions.push((()=>"readable"===source._state?ReadableStreamCancel(source,error):promiseResolvedWith(void 0))),shutdownWithAction((()=>Promise.all(actions.map((action=>action())))),!0,error)},signal.aborted)return void abortAlgorithm();signal.addEventListener("abort",abortAlgorithm)}if(isOrBecomesErrored(source,reader._closedPromise,(storedError=>{preventAbort?shutdown(!0,storedError):shutdownWithAction((()=>WritableStreamAbort(dest,storedError)),!0,storedError)})),isOrBecomesErrored(dest,writer._closedPromise,(storedError=>{preventCancel?shutdown(!0,storedError):shutdownWithAction((()=>ReadableStreamCancel(source,storedError)),!0,storedError)})),function isOrBecomesClosed(stream,promise,action){"closed"===stream._state?action():uponFulfillment(promise,action)}(source,reader._closedPromise,(()=>{preventClose?shutdown():shutdownWithAction((()=>function WritableStreamDefaultWriterCloseWithErrorPropagation(writer){const stream=writer._ownerWritableStream,state=stream._state;return WritableStreamCloseQueuedOrInFlight(stream)||"closed"===state?promiseResolvedWith(void 0):"errored"===state?promiseRejectedWith(stream._storedError):WritableStreamDefaultWriterClose(writer)}(writer)))})),WritableStreamCloseQueuedOrInFlight(dest)||"closed"===dest._state){const destClosed=new TypeError("the destination writable stream closed before all data could be piped to it");preventCancel?shutdown(!0,destClosed):shutdownWithAction((()=>ReadableStreamCancel(source,destClosed)),!0,destClosed)}function waitForWritesToFinish(){const oldCurrentWrite=currentWrite;return PerformPromiseThen(currentWrite,(()=>oldCurrentWrite!==currentWrite?waitForWritesToFinish():void 0))}function isOrBecomesErrored(stream,promise,action){"errored"===stream._state?action(stream._storedError):uponRejection(promise,action)}function shutdownWithAction(action,originalIsError,originalError){function doTheRest(){uponPromise(action(),(()=>finalize(originalIsError,originalError)),(newError=>finalize(!0,newError)))}shuttingDown||(shuttingDown=!0,"writable"!==dest._state||WritableStreamCloseQueuedOrInFlight(dest)?doTheRest():uponFulfillment(waitForWritesToFinish(),doTheRest))}function shutdown(isError,error){shuttingDown||(shuttingDown=!0,"writable"!==dest._state||WritableStreamCloseQueuedOrInFlight(dest)?finalize(isError,error):uponFulfillment(waitForWritesToFinish(),(()=>finalize(isError,error))))}function finalize(isError,error){WritableStreamDefaultWriterRelease(writer),ReadableStreamReaderGenericRelease(reader),void 0!==signal&&signal.removeEventListener("abort",abortAlgorithm),isError?reject(error):resolve(void 0)}setPromiseIsHandledToTrue(function pipeLoop(){return newPromise(((resolveLoop,rejectLoop)=>{!function next(done){done?resolveLoop():PerformPromiseThen(function pipeStep(){if(shuttingDown)return promiseResolvedWith(!0);return PerformPromiseThen(writer._readyPromise,(()=>newPromise(((resolveRead,rejectRead)=>{ReadableStreamDefaultReaderRead(reader,{_chunkSteps:chunk=>{currentWrite=PerformPromiseThen(WritableStreamDefaultWriterWrite(writer,chunk),void 0,noop),resolveRead(!1)},_closeSteps:()=>resolveRead(!0),_errorSteps:rejectRead})}))))}(),next,rejectLoop)}(!1)}))}())}))}class ReadableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("desiredSize");return ReadableStreamDefaultControllerGetDesiredSize(this)}close(){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("close");if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))throw new TypeError("The stream is not in a state that permits close");ReadableStreamDefaultControllerClose(this)}enqueue(chunk=undefined){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("enqueue");if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))throw new TypeError("The stream is not in a state that permits enqueue");return ReadableStreamDefaultControllerEnqueue(this,chunk)}error(e=undefined){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("error");ReadableStreamDefaultControllerError(this,e)}[CancelSteps](reason){ResetQueue(this);const result=this._cancelAlgorithm(reason);return ReadableStreamDefaultControllerClearAlgorithms(this),result}[PullSteps](readRequest){const stream=this._controlledReadableStream;if(this._queue.length>0){const chunk=DequeueValue(this);this._closeRequested&&0===this._queue.length?(ReadableStreamDefaultControllerClearAlgorithms(this),ReadableStreamClose(stream)):ReadableStreamDefaultControllerCallPullIfNeeded(this),readRequest._chunkSteps(chunk)}else ReadableStreamAddReadRequest(stream,readRequest),ReadableStreamDefaultControllerCallPullIfNeeded(this)}}function IsReadableStreamDefaultController(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_controlledReadableStream")&&x instanceof ReadableStreamDefaultController)}function ReadableStreamDefaultControllerCallPullIfNeeded(controller){if(!ReadableStreamDefaultControllerShouldCallPull(controller))return;if(controller._pulling)return void(controller._pullAgain=!0);controller._pulling=!0;uponPromise(controller._pullAlgorithm(),(()=>{controller._pulling=!1,controller._pullAgain&&(controller._pullAgain=!1,ReadableStreamDefaultControllerCallPullIfNeeded(controller))}),(e=>{ReadableStreamDefaultControllerError(controller,e)}))}function ReadableStreamDefaultControllerShouldCallPull(controller){const stream=controller._controlledReadableStream;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller))return!1;if(!controller._started)return!1;if(IsReadableStreamLocked(stream)&&ReadableStreamGetNumReadRequests(stream)>0)return!0;return ReadableStreamDefaultControllerGetDesiredSize(controller)>0}function ReadableStreamDefaultControllerClearAlgorithms(controller){controller._pullAlgorithm=void 0,controller._cancelAlgorithm=void 0,controller._strategySizeAlgorithm=void 0}function ReadableStreamDefaultControllerClose(controller){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller))return;const stream=controller._controlledReadableStream;controller._closeRequested=!0,0===controller._queue.length&&(ReadableStreamDefaultControllerClearAlgorithms(controller),ReadableStreamClose(stream))}function ReadableStreamDefaultControllerEnqueue(controller,chunk){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller))return;const stream=controller._controlledReadableStream;if(IsReadableStreamLocked(stream)&&ReadableStreamGetNumReadRequests(stream)>0)ReadableStreamFulfillReadRequest(stream,chunk,!1);else{let chunkSize;try{chunkSize=controller._strategySizeAlgorithm(chunk)}catch(chunkSizeE){throw ReadableStreamDefaultControllerError(controller,chunkSizeE),chunkSizeE}try{EnqueueValueWithSize(controller,chunk,chunkSize)}catch(enqueueE){throw ReadableStreamDefaultControllerError(controller,enqueueE),enqueueE}}ReadableStreamDefaultControllerCallPullIfNeeded(controller)}function ReadableStreamDefaultControllerError(controller,e){const stream=controller._controlledReadableStream;"readable"===stream._state&&(ResetQueue(controller),ReadableStreamDefaultControllerClearAlgorithms(controller),ReadableStreamError(stream,e))}function ReadableStreamDefaultControllerGetDesiredSize(controller){const state=controller._controlledReadableStream._state;return"errored"===state?null:"closed"===state?0:controller._strategyHWM-controller._queueTotalSize}function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller){const state=controller._controlledReadableStream._state;return!controller._closeRequested&&"readable"===state}function SetUpReadableStreamDefaultController(stream,controller,startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark,sizeAlgorithm){controller._controlledReadableStream=stream,controller._queue=void 0,controller._queueTotalSize=void 0,ResetQueue(controller),controller._started=!1,controller._closeRequested=!1,controller._pullAgain=!1,controller._pulling=!1,controller._strategySizeAlgorithm=sizeAlgorithm,controller._strategyHWM=highWaterMark,controller._pullAlgorithm=pullAlgorithm,controller._cancelAlgorithm=cancelAlgorithm,stream._readableStreamController=controller;uponPromise(promiseResolvedWith(startAlgorithm()),(()=>{controller._started=!0,ReadableStreamDefaultControllerCallPullIfNeeded(controller)}),(r=>{ReadableStreamDefaultControllerError(controller,r)}))}function defaultControllerBrandCheckException$1(name){return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`)}function ReadableStreamTee(stream,cloneForBranch2){return IsReadableByteStreamController(stream._readableStreamController)?function ReadableByteStreamTee(stream){let reason1,reason2,branch1,branch2,resolveCancelPromise,reader=AcquireReadableStreamDefaultReader(stream),reading=!1,readAgainForBranch1=!1,readAgainForBranch2=!1,canceled1=!1,canceled2=!1;const cancelPromise=newPromise((resolve=>{resolveCancelPromise=resolve}));function forwardReaderError(thisReader){uponRejection(thisReader._closedPromise,(r=>{thisReader===reader&&(ReadableByteStreamControllerError(branch1._readableStreamController,r),ReadableByteStreamControllerError(branch2._readableStreamController,r),canceled1&&canceled2||resolveCancelPromise(void 0))}))}function pullWithDefaultReader(){IsReadableStreamBYOBReader(reader)&&(ReadableStreamReaderGenericRelease(reader),reader=AcquireReadableStreamDefaultReader(stream),forwardReaderError(reader));ReadableStreamDefaultReaderRead(reader,{_chunkSteps:chunk=>{queueMicrotask((()=>{readAgainForBranch1=!1,readAgainForBranch2=!1;const chunk1=chunk;let chunk2=chunk;if(!canceled1&&!canceled2)try{chunk2=CloneAsUint8Array(chunk)}catch(cloneE){return ReadableByteStreamControllerError(branch1._readableStreamController,cloneE),ReadableByteStreamControllerError(branch2._readableStreamController,cloneE),void resolveCancelPromise(ReadableStreamCancel(stream,cloneE))}canceled1||ReadableByteStreamControllerEnqueue(branch1._readableStreamController,chunk1),canceled2||ReadableByteStreamControllerEnqueue(branch2._readableStreamController,chunk2),reading=!1,readAgainForBranch1?pull1Algorithm():readAgainForBranch2&&pull2Algorithm()}))},_closeSteps:()=>{reading=!1,canceled1||ReadableByteStreamControllerClose(branch1._readableStreamController),canceled2||ReadableByteStreamControllerClose(branch2._readableStreamController),branch1._readableStreamController._pendingPullIntos.length>0&&ReadableByteStreamControllerRespond(branch1._readableStreamController,0),branch2._readableStreamController._pendingPullIntos.length>0&&ReadableByteStreamControllerRespond(branch2._readableStreamController,0),canceled1&&canceled2||resolveCancelPromise(void 0)},_errorSteps:()=>{reading=!1}})}function pullWithBYOBReader(view,forBranch2){IsReadableStreamDefaultReader(reader)&&(ReadableStreamReaderGenericRelease(reader),reader=AcquireReadableStreamBYOBReader(stream),forwardReaderError(reader));const byobBranch=forBranch2?branch2:branch1,otherBranch=forBranch2?branch1:branch2;ReadableStreamBYOBReaderRead(reader,view,{_chunkSteps:chunk=>{queueMicrotask((()=>{readAgainForBranch1=!1,readAgainForBranch2=!1;const byobCanceled=forBranch2?canceled2:canceled1;if(forBranch2?canceled1:canceled2)byobCanceled||ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController,chunk);else{let clonedChunk;try{clonedChunk=CloneAsUint8Array(chunk)}catch(cloneE){return ReadableByteStreamControllerError(byobBranch._readableStreamController,cloneE),ReadableByteStreamControllerError(otherBranch._readableStreamController,cloneE),void resolveCancelPromise(ReadableStreamCancel(stream,cloneE))}byobCanceled||ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController,chunk),ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController,clonedChunk)}reading=!1,readAgainForBranch1?pull1Algorithm():readAgainForBranch2&&pull2Algorithm()}))},_closeSteps:chunk=>{reading=!1;const byobCanceled=forBranch2?canceled2:canceled1,otherCanceled=forBranch2?canceled1:canceled2;byobCanceled||ReadableByteStreamControllerClose(byobBranch._readableStreamController),otherCanceled||ReadableByteStreamControllerClose(otherBranch._readableStreamController),void 0!==chunk&&(byobCanceled||ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController,chunk),!otherCanceled&&otherBranch._readableStreamController._pendingPullIntos.length>0&&ReadableByteStreamControllerRespond(otherBranch._readableStreamController,0)),byobCanceled&&otherCanceled||resolveCancelPromise(void 0)},_errorSteps:()=>{reading=!1}})}function pull1Algorithm(){if(reading)return readAgainForBranch1=!0,promiseResolvedWith(void 0);reading=!0;const byobRequest=ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);return null===byobRequest?pullWithDefaultReader():pullWithBYOBReader(byobRequest._view,!1),promiseResolvedWith(void 0)}function pull2Algorithm(){if(reading)return readAgainForBranch2=!0,promiseResolvedWith(void 0);reading=!0;const byobRequest=ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);return null===byobRequest?pullWithDefaultReader():pullWithBYOBReader(byobRequest._view,!0),promiseResolvedWith(void 0)}function cancel1Algorithm(reason){if(canceled1=!0,reason1=reason,canceled2){const compositeReason=CreateArrayFromList([reason1,reason2]),cancelResult=ReadableStreamCancel(stream,compositeReason);resolveCancelPromise(cancelResult)}return cancelPromise}function cancel2Algorithm(reason){if(canceled2=!0,reason2=reason,canceled1){const compositeReason=CreateArrayFromList([reason1,reason2]),cancelResult=ReadableStreamCancel(stream,compositeReason);resolveCancelPromise(cancelResult)}return cancelPromise}function startAlgorithm(){}return branch1=CreateReadableByteStream(startAlgorithm,pull1Algorithm,cancel1Algorithm),branch2=CreateReadableByteStream(startAlgorithm,pull2Algorithm,cancel2Algorithm),forwardReaderError(reader),[branch1,branch2]}(stream):function ReadableStreamDefaultTee(stream,cloneForBranch2){const reader=AcquireReadableStreamDefaultReader(stream);let reason1,reason2,branch1,branch2,resolveCancelPromise,reading=!1,readAgain=!1,canceled1=!1,canceled2=!1;const cancelPromise=newPromise((resolve=>{resolveCancelPromise=resolve}));function pullAlgorithm(){if(reading)return readAgain=!0,promiseResolvedWith(void 0);reading=!0;return ReadableStreamDefaultReaderRead(reader,{_chunkSteps:chunk=>{queueMicrotask((()=>{readAgain=!1;const chunk1=chunk,chunk2=chunk;canceled1||ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController,chunk1),canceled2||ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController,chunk2),reading=!1,readAgain&&pullAlgorithm()}))},_closeSteps:()=>{reading=!1,canceled1||ReadableStreamDefaultControllerClose(branch1._readableStreamController),canceled2||ReadableStreamDefaultControllerClose(branch2._readableStreamController),canceled1&&canceled2||resolveCancelPromise(void 0)},_errorSteps:()=>{reading=!1}}),promiseResolvedWith(void 0)}function cancel1Algorithm(reason){if(canceled1=!0,reason1=reason,canceled2){const compositeReason=CreateArrayFromList([reason1,reason2]),cancelResult=ReadableStreamCancel(stream,compositeReason);resolveCancelPromise(cancelResult)}return cancelPromise}function cancel2Algorithm(reason){if(canceled2=!0,reason2=reason,canceled1){const compositeReason=CreateArrayFromList([reason1,reason2]),cancelResult=ReadableStreamCancel(stream,compositeReason);resolveCancelPromise(cancelResult)}return cancelPromise}function startAlgorithm(){}return branch1=CreateReadableStream(startAlgorithm,pullAlgorithm,cancel1Algorithm),branch2=CreateReadableStream(startAlgorithm,pullAlgorithm,cancel2Algorithm),uponRejection(reader._closedPromise,(r=>{ReadableStreamDefaultControllerError(branch1._readableStreamController,r),ReadableStreamDefaultControllerError(branch2._readableStreamController,r),canceled1&&canceled2||resolveCancelPromise(void 0)})),[branch1,branch2]}(stream)}function convertUnderlyingSourceCancelCallback(fn,original,context){return assertFunction(fn,context),reason=>promiseCall(fn,original,[reason])}function convertUnderlyingSourcePullCallback(fn,original,context){return assertFunction(fn,context),controller=>promiseCall(fn,original,[controller])}function convertUnderlyingSourceStartCallback(fn,original,context){return assertFunction(fn,context),controller=>reflectCall(fn,original,[controller])}function convertReadableStreamType(type,context){if("bytes"!==(type=`${type}`))throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);return type}function convertReadableStreamReaderMode(mode,context){if("byob"!==(mode=`${mode}`))throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);return mode}function convertPipeOptions(options,context){assertDictionary(options,context);const preventAbort=null==options?void 0:options.preventAbort,preventCancel=null==options?void 0:options.preventCancel,preventClose=null==options?void 0:options.preventClose,signal=null==options?void 0:options.signal;return void 0!==signal&&function assertAbortSignal(signal,context){if(!function isAbortSignal(value){if("object"!=typeof value||null===value)return!1;try{return"boolean"==typeof value.aborted}catch(_a){return!1}}(signal))throw new TypeError(`${context} is not an AbortSignal.`)}(signal,`${context} has member 'signal' that`),{preventAbort:Boolean(preventAbort),preventCancel:Boolean(preventCancel),preventClose:Boolean(preventClose),signal:signal}}Object.defineProperties(ReadableStreamDefaultController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableStreamDefaultController.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});class ReadableStream{constructor(rawUnderlyingSource={},rawStrategy={}){void 0===rawUnderlyingSource?rawUnderlyingSource=null:assertObject(rawUnderlyingSource,"First parameter");const strategy=convertQueuingStrategy(rawStrategy,"Second parameter"),underlyingSource=function convertUnderlyingDefaultOrByteSource(source,context){assertDictionary(source,context);const original=source,autoAllocateChunkSize=null==original?void 0:original.autoAllocateChunkSize,cancel=null==original?void 0:original.cancel,pull=null==original?void 0:original.pull,start=null==original?void 0:original.start,type=null==original?void 0:original.type;return{autoAllocateChunkSize:void 0===autoAllocateChunkSize?void 0:convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize,`${context} has member 'autoAllocateChunkSize' that`),cancel:void 0===cancel?void 0:convertUnderlyingSourceCancelCallback(cancel,original,`${context} has member 'cancel' that`),pull:void 0===pull?void 0:convertUnderlyingSourcePullCallback(pull,original,`${context} has member 'pull' that`),start:void 0===start?void 0:convertUnderlyingSourceStartCallback(start,original,`${context} has member 'start' that`),type:void 0===type?void 0:convertReadableStreamType(type,`${context} has member 'type' that`)}}(rawUnderlyingSource,"First parameter");if(InitializeReadableStream(this),"bytes"===underlyingSource.type){if(void 0!==strategy.size)throw new RangeError("The strategy for a byte stream cannot have a size function");!function SetUpReadableByteStreamControllerFromUnderlyingSource(stream,underlyingByteSource,highWaterMark){const controller=Object.create(ReadableByteStreamController.prototype);let startAlgorithm=()=>{},pullAlgorithm=()=>promiseResolvedWith(void 0),cancelAlgorithm=()=>promiseResolvedWith(void 0);void 0!==underlyingByteSource.start&&(startAlgorithm=()=>underlyingByteSource.start(controller)),void 0!==underlyingByteSource.pull&&(pullAlgorithm=()=>underlyingByteSource.pull(controller)),void 0!==underlyingByteSource.cancel&&(cancelAlgorithm=reason=>underlyingByteSource.cancel(reason));const autoAllocateChunkSize=underlyingByteSource.autoAllocateChunkSize;if(0===autoAllocateChunkSize)throw new TypeError("autoAllocateChunkSize must be greater than 0");SetUpReadableByteStreamController(stream,controller,startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark,autoAllocateChunkSize)}(this,underlyingSource,ExtractHighWaterMark(strategy,0))}else{const sizeAlgorithm=ExtractSizeAlgorithm(strategy);!function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream,underlyingSource,highWaterMark,sizeAlgorithm){const controller=Object.create(ReadableStreamDefaultController.prototype);let startAlgorithm=()=>{},pullAlgorithm=()=>promiseResolvedWith(void 0),cancelAlgorithm=()=>promiseResolvedWith(void 0);void 0!==underlyingSource.start&&(startAlgorithm=()=>underlyingSource.start(controller)),void 0!==underlyingSource.pull&&(pullAlgorithm=()=>underlyingSource.pull(controller)),void 0!==underlyingSource.cancel&&(cancelAlgorithm=reason=>underlyingSource.cancel(reason)),SetUpReadableStreamDefaultController(stream,controller,startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark,sizeAlgorithm)}(this,underlyingSource,ExtractHighWaterMark(strategy,1),sizeAlgorithm)}}get locked(){if(!IsReadableStream(this))throw streamBrandCheckException$1("locked");return IsReadableStreamLocked(this)}cancel(reason=undefined){return IsReadableStream(this)?IsReadableStreamLocked(this)?promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader")):ReadableStreamCancel(this,reason):promiseRejectedWith(streamBrandCheckException$1("cancel"))}getReader(rawOptions=undefined){if(!IsReadableStream(this))throw streamBrandCheckException$1("getReader");return void 0===function convertReaderOptions(options,context){assertDictionary(options,context);const mode=null==options?void 0:options.mode;return{mode:void 0===mode?void 0:convertReadableStreamReaderMode(mode,`${context} has member 'mode' that`)}}(rawOptions,"First parameter").mode?AcquireReadableStreamDefaultReader(this):AcquireReadableStreamBYOBReader(this)}pipeThrough(rawTransform,rawOptions={}){if(!IsReadableStream(this))throw streamBrandCheckException$1("pipeThrough");assertRequiredArgument(rawTransform,1,"pipeThrough");const transform=function convertReadableWritablePair(pair,context){assertDictionary(pair,context);const readable=null==pair?void 0:pair.readable;assertRequiredField(readable,"readable","ReadableWritablePair"),assertReadableStream(readable,`${context} has member 'readable' that`);const writable=null==pair?void 0:pair.writable;return assertRequiredField(writable,"writable","ReadableWritablePair"),assertWritableStream(writable,`${context} has member 'writable' that`),{readable:readable,writable:writable}}(rawTransform,"First parameter"),options=convertPipeOptions(rawOptions,"Second parameter");if(IsReadableStreamLocked(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(IsWritableStreamLocked(transform.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return setPromiseIsHandledToTrue(ReadableStreamPipeTo(this,transform.writable,options.preventClose,options.preventAbort,options.preventCancel,options.signal)),transform.readable}pipeTo(destination,rawOptions={}){if(!IsReadableStream(this))return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));if(void 0===destination)return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");if(!IsWritableStream(destination))return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let options;try{options=convertPipeOptions(rawOptions,"Second parameter")}catch(e){return promiseRejectedWith(e)}return IsReadableStreamLocked(this)?promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):IsWritableStreamLocked(destination)?promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):ReadableStreamPipeTo(this,destination,options.preventClose,options.preventAbort,options.preventCancel,options.signal)}tee(){if(!IsReadableStream(this))throw streamBrandCheckException$1("tee");return CreateArrayFromList(ReadableStreamTee(this))}values(rawOptions=undefined){if(!IsReadableStream(this))throw streamBrandCheckException$1("values");return function AcquireReadableStreamAsyncIterator(stream,preventCancel){const reader=AcquireReadableStreamDefaultReader(stream),impl=new ReadableStreamAsyncIteratorImpl(reader,preventCancel),iterator=Object.create(ReadableStreamAsyncIteratorPrototype);return iterator._asyncIteratorImpl=impl,iterator}(this,function convertIteratorOptions(options,context){assertDictionary(options,context);const preventCancel=null==options?void 0:options.preventCancel;return{preventCancel:Boolean(preventCancel)}}(rawOptions,"First parameter").preventCancel)}}function CreateReadableStream(startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark=1,sizeAlgorithm=(()=>1)){const stream=Object.create(ReadableStream.prototype);InitializeReadableStream(stream);return SetUpReadableStreamDefaultController(stream,Object.create(ReadableStreamDefaultController.prototype),startAlgorithm,pullAlgorithm,cancelAlgorithm,highWaterMark,sizeAlgorithm),stream}function CreateReadableByteStream(startAlgorithm,pullAlgorithm,cancelAlgorithm){const stream=Object.create(ReadableStream.prototype);InitializeReadableStream(stream);return SetUpReadableByteStreamController(stream,Object.create(ReadableByteStreamController.prototype),startAlgorithm,pullAlgorithm,cancelAlgorithm,0,void 0),stream}function InitializeReadableStream(stream){stream._state="readable",stream._reader=void 0,stream._storedError=void 0,stream._disturbed=!1}function IsReadableStream(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_readableStreamController")&&x instanceof ReadableStream)}function IsReadableStreamLocked(stream){return void 0!==stream._reader}function ReadableStreamCancel(stream,reason){if(stream._disturbed=!0,"closed"===stream._state)return promiseResolvedWith(void 0);if("errored"===stream._state)return promiseRejectedWith(stream._storedError);ReadableStreamClose(stream);const reader=stream._reader;void 0!==reader&&IsReadableStreamBYOBReader(reader)&&(reader._readIntoRequests.forEach((readIntoRequest=>{readIntoRequest._closeSteps(void 0)})),reader._readIntoRequests=new SimpleQueue);return transformPromiseWith(stream._readableStreamController[CancelSteps](reason),noop)}function ReadableStreamClose(stream){stream._state="closed";const reader=stream._reader;void 0!==reader&&(defaultReaderClosedPromiseResolve(reader),IsReadableStreamDefaultReader(reader)&&(reader._readRequests.forEach((readRequest=>{readRequest._closeSteps()})),reader._readRequests=new SimpleQueue))}function ReadableStreamError(stream,e){stream._state="errored",stream._storedError=e;const reader=stream._reader;void 0!==reader&&(defaultReaderClosedPromiseReject(reader,e),IsReadableStreamDefaultReader(reader)?(reader._readRequests.forEach((readRequest=>{readRequest._errorSteps(e)})),reader._readRequests=new SimpleQueue):(reader._readIntoRequests.forEach((readIntoRequest=>{readIntoRequest._errorSteps(e)})),reader._readIntoRequests=new SimpleQueue))}function streamBrandCheckException$1(name){return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`)}function convertQueuingStrategyInit(init,context){assertDictionary(init,context);const highWaterMark=null==init?void 0:init.highWaterMark;return assertRequiredField(highWaterMark,"highWaterMark","QueuingStrategyInit"),{highWaterMark:convertUnrestrictedDouble(highWaterMark)}}Object.defineProperties(ReadableStream.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableStream.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:!0}),"symbol"==typeof Symbol.asyncIterator&&Object.defineProperty(ReadableStream.prototype,Symbol.asyncIterator,{value:ReadableStream.prototype.values,writable:!0,configurable:!0});const byteLengthSizeFunction=chunk=>chunk.byteLength;try{Object.defineProperty(byteLengthSizeFunction,"name",{value:"size",configurable:!0})}catch(_a){}class ByteLengthQueuingStrategy{constructor(options){assertRequiredArgument(options,1,"ByteLengthQueuingStrategy"),options=convertQueuingStrategyInit(options,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=options.highWaterMark}get highWaterMark(){if(!IsByteLengthQueuingStrategy(this))throw byteLengthBrandCheckException("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!IsByteLengthQueuingStrategy(this))throw byteLengthBrandCheckException("size");return byteLengthSizeFunction}}function byteLengthBrandCheckException(name){return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`)}function IsByteLengthQueuingStrategy(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_byteLengthQueuingStrategyHighWaterMark")&&x instanceof ByteLengthQueuingStrategy)}Object.defineProperties(ByteLengthQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ByteLengthQueuingStrategy.prototype,Symbol.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});const countSizeFunction=()=>1;try{Object.defineProperty(countSizeFunction,"name",{value:"size",configurable:!0})}catch(_a){}class CountQueuingStrategy{constructor(options){assertRequiredArgument(options,1,"CountQueuingStrategy"),options=convertQueuingStrategyInit(options,"First parameter"),this._countQueuingStrategyHighWaterMark=options.highWaterMark}get highWaterMark(){if(!IsCountQueuingStrategy(this))throw countBrandCheckException("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!IsCountQueuingStrategy(this))throw countBrandCheckException("size");return countSizeFunction}}function countBrandCheckException(name){return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`)}function IsCountQueuingStrategy(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_countQueuingStrategyHighWaterMark")&&x instanceof CountQueuingStrategy)}function convertTransformerFlushCallback(fn,original,context){return assertFunction(fn,context),controller=>promiseCall(fn,original,[controller])}function convertTransformerStartCallback(fn,original,context){return assertFunction(fn,context),controller=>reflectCall(fn,original,[controller])}function convertTransformerTransformCallback(fn,original,context){return assertFunction(fn,context),(chunk,controller)=>promiseCall(fn,original,[chunk,controller])}Object.defineProperties(CountQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(CountQueuingStrategy.prototype,Symbol.toStringTag,{value:"CountQueuingStrategy",configurable:!0});class TransformStream{constructor(rawTransformer={},rawWritableStrategy={},rawReadableStrategy={}){void 0===rawTransformer&&(rawTransformer=null);const writableStrategy=convertQueuingStrategy(rawWritableStrategy,"Second parameter"),readableStrategy=convertQueuingStrategy(rawReadableStrategy,"Third parameter"),transformer=function convertTransformer(original,context){assertDictionary(original,context);const flush=null==original?void 0:original.flush,readableType=null==original?void 0:original.readableType,start=null==original?void 0:original.start,transform=null==original?void 0:original.transform,writableType=null==original?void 0:original.writableType;return{flush:void 0===flush?void 0:convertTransformerFlushCallback(flush,original,`${context} has member 'flush' that`),readableType:readableType,start:void 0===start?void 0:convertTransformerStartCallback(start,original,`${context} has member 'start' that`),transform:void 0===transform?void 0:convertTransformerTransformCallback(transform,original,`${context} has member 'transform' that`),writableType:writableType}}(rawTransformer,"First parameter");if(void 0!==transformer.readableType)throw new RangeError("Invalid readableType specified");if(void 0!==transformer.writableType)throw new RangeError("Invalid writableType specified");const readableHighWaterMark=ExtractHighWaterMark(readableStrategy,0),readableSizeAlgorithm=ExtractSizeAlgorithm(readableStrategy),writableHighWaterMark=ExtractHighWaterMark(writableStrategy,1),writableSizeAlgorithm=ExtractSizeAlgorithm(writableStrategy);let startPromise_resolve;!function InitializeTransformStream(stream,startPromise,writableHighWaterMark,writableSizeAlgorithm,readableHighWaterMark,readableSizeAlgorithm){function startAlgorithm(){return startPromise}function writeAlgorithm(chunk){return function TransformStreamDefaultSinkWriteAlgorithm(stream,chunk){const controller=stream._transformStreamController;if(stream._backpressure){return transformPromiseWith(stream._backpressureChangePromise,(()=>{const writable=stream._writable;if("erroring"===writable._state)throw writable._storedError;return TransformStreamDefaultControllerPerformTransform(controller,chunk)}))}return TransformStreamDefaultControllerPerformTransform(controller,chunk)}(stream,chunk)}function abortAlgorithm(reason){return function TransformStreamDefaultSinkAbortAlgorithm(stream,reason){return TransformStreamError(stream,reason),promiseResolvedWith(void 0)}(stream,reason)}function closeAlgorithm(){return function TransformStreamDefaultSinkCloseAlgorithm(stream){const readable=stream._readable,controller=stream._transformStreamController,flushPromise=controller._flushAlgorithm();return TransformStreamDefaultControllerClearAlgorithms(controller),transformPromiseWith(flushPromise,(()=>{if("errored"===readable._state)throw readable._storedError;ReadableStreamDefaultControllerClose(readable._readableStreamController)}),(r=>{throw TransformStreamError(stream,r),readable._storedError}))}(stream)}function pullAlgorithm(){return function TransformStreamDefaultSourcePullAlgorithm(stream){return TransformStreamSetBackpressure(stream,!1),stream._backpressureChangePromise}(stream)}function cancelAlgorithm(reason){return TransformStreamErrorWritableAndUnblockWrite(stream,reason),promiseResolvedWith(void 0)}stream._writable=function CreateWritableStream(startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,highWaterMark=1,sizeAlgorithm=(()=>1)){const stream=Object.create(WritableStream.prototype);return InitializeWritableStream(stream),SetUpWritableStreamDefaultController(stream,Object.create(WritableStreamDefaultController.prototype),startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,highWaterMark,sizeAlgorithm),stream}(startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,writableHighWaterMark,writableSizeAlgorithm),stream._readable=CreateReadableStream(startAlgorithm,pullAlgorithm,cancelAlgorithm,readableHighWaterMark,readableSizeAlgorithm),stream._backpressure=void 0,stream._backpressureChangePromise=void 0,stream._backpressureChangePromise_resolve=void 0,TransformStreamSetBackpressure(stream,!0),stream._transformStreamController=void 0}(this,newPromise((resolve=>{startPromise_resolve=resolve})),writableHighWaterMark,writableSizeAlgorithm,readableHighWaterMark,readableSizeAlgorithm),function SetUpTransformStreamDefaultControllerFromTransformer(stream,transformer){const controller=Object.create(TransformStreamDefaultController.prototype);let transformAlgorithm=chunk=>{try{return TransformStreamDefaultControllerEnqueue(controller,chunk),promiseResolvedWith(void 0)}catch(transformResultE){return promiseRejectedWith(transformResultE)}},flushAlgorithm=()=>promiseResolvedWith(void 0);void 0!==transformer.transform&&(transformAlgorithm=chunk=>transformer.transform(chunk,controller));void 0!==transformer.flush&&(flushAlgorithm=()=>transformer.flush(controller));!function SetUpTransformStreamDefaultController(stream,controller,transformAlgorithm,flushAlgorithm){controller._controlledTransformStream=stream,stream._transformStreamController=controller,controller._transformAlgorithm=transformAlgorithm,controller._flushAlgorithm=flushAlgorithm}(stream,controller,transformAlgorithm,flushAlgorithm)}(this,transformer),void 0!==transformer.start?startPromise_resolve(transformer.start(this._transformStreamController)):startPromise_resolve(void 0)}get readable(){if(!IsTransformStream(this))throw streamBrandCheckException("readable");return this._readable}get writable(){if(!IsTransformStream(this))throw streamBrandCheckException("writable");return this._writable}}function IsTransformStream(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_transformStreamController")&&x instanceof TransformStream)}function TransformStreamError(stream,e){ReadableStreamDefaultControllerError(stream._readable._readableStreamController,e),TransformStreamErrorWritableAndUnblockWrite(stream,e)}function TransformStreamErrorWritableAndUnblockWrite(stream,e){TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController),WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController,e),stream._backpressure&&TransformStreamSetBackpressure(stream,!1)}function TransformStreamSetBackpressure(stream,backpressure){void 0!==stream._backpressureChangePromise&&stream._backpressureChangePromise_resolve(),stream._backpressureChangePromise=newPromise((resolve=>{stream._backpressureChangePromise_resolve=resolve})),stream._backpressure=backpressure}Object.defineProperties(TransformStream.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(TransformStream.prototype,Symbol.toStringTag,{value:"TransformStream",configurable:!0});class TransformStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("desiredSize");return ReadableStreamDefaultControllerGetDesiredSize(this._controlledTransformStream._readable._readableStreamController)}enqueue(chunk=undefined){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("enqueue");TransformStreamDefaultControllerEnqueue(this,chunk)}error(reason=undefined){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("error");!function TransformStreamDefaultControllerError(controller,e){TransformStreamError(controller._controlledTransformStream,e)}(this,reason)}terminate(){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("terminate");!function TransformStreamDefaultControllerTerminate(controller){const stream=controller._controlledTransformStream;ReadableStreamDefaultControllerClose(stream._readable._readableStreamController);const error=new TypeError("TransformStream terminated");TransformStreamErrorWritableAndUnblockWrite(stream,error)}(this)}}function IsTransformStreamDefaultController(x){return!!typeIsObject(x)&&(!!Object.prototype.hasOwnProperty.call(x,"_controlledTransformStream")&&x instanceof TransformStreamDefaultController)}function TransformStreamDefaultControllerClearAlgorithms(controller){controller._transformAlgorithm=void 0,controller._flushAlgorithm=void 0}function TransformStreamDefaultControllerEnqueue(controller,chunk){const stream=controller._controlledTransformStream,readableController=stream._readable._readableStreamController;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController))throw new TypeError("Readable side is not in a state that permits enqueue");try{ReadableStreamDefaultControllerEnqueue(readableController,chunk)}catch(e){throw TransformStreamErrorWritableAndUnblockWrite(stream,e),stream._readable._storedError}const backpressure=function ReadableStreamDefaultControllerHasBackpressure(controller){return!ReadableStreamDefaultControllerShouldCallPull(controller)}(readableController);backpressure!==stream._backpressure&&TransformStreamSetBackpressure(stream,!0)}function TransformStreamDefaultControllerPerformTransform(controller,chunk){return transformPromiseWith(controller._transformAlgorithm(chunk),void 0,(r=>{throw TransformStreamError(controller._controlledTransformStream,r),r}))}function defaultControllerBrandCheckException(name){return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`)}function streamBrandCheckException(name){return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`)}Object.defineProperties(TransformStreamDefaultController.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(TransformStreamDefaultController.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});const exports$1={ReadableStream:ReadableStream,ReadableStreamDefaultController:ReadableStreamDefaultController,ReadableByteStreamController:ReadableByteStreamController,ReadableStreamBYOBRequest:ReadableStreamBYOBRequest,ReadableStreamDefaultReader:ReadableStreamDefaultReader,ReadableStreamBYOBReader:ReadableStreamBYOBReader,WritableStream:WritableStream,WritableStreamDefaultController:WritableStreamDefaultController,WritableStreamDefaultWriter:WritableStreamDefaultWriter,ByteLengthQueuingStrategy:ByteLengthQueuingStrategy,CountQueuingStrategy:CountQueuingStrategy,TransformStream:TransformStream,TransformStreamDefaultController:TransformStreamDefaultController};if(void 0!==globals)for(const prop in exports$1)Object.prototype.hasOwnProperty.call(exports$1,prop)&&Object.defineProperty(globals,prop,{value:exports$1[prop],writable:!0,configurable:!0});exports.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy,exports.CountQueuingStrategy=CountQueuingStrategy,exports.ReadableByteStreamController=ReadableByteStreamController,exports.ReadableStream=ReadableStream,exports.ReadableStreamBYOBReader=ReadableStreamBYOBReader,exports.ReadableStreamBYOBRequest=ReadableStreamBYOBRequest,exports.ReadableStreamDefaultController=ReadableStreamDefaultController,exports.ReadableStreamDefaultReader=ReadableStreamDefaultReader,exports.TransformStream=TransformStream,exports.TransformStreamDefaultController=TransformStreamDefaultController,exports.WritableStream=WritableStream,exports.WritableStreamDefaultController=WritableStreamDefaultController,exports.WritableStreamDefaultWriter=WritableStreamDefaultWriter}));
//# sourceMappingURL=polyfill.es6.min.js.map

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FetchPolyfill = {}));
})(this, (function (exports) { 'use strict';

    function normalizeName(name) {
        if (typeof name !== "string") {
            name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
        }
        return name.toLowerCase();
    }
    function normalizeValue(value) {
        if (typeof value !== "string") {
            value = String(value);
        }
        return value;
    }
    function iteratorFor(items) {
        var iterator = {
            // @ts-ignore
            next() {
                var value = items.shift();
                return { done: value === undefined, value: value };
            },
            [Symbol.iterator]() {
                return iterator;
            },
        };
        return iterator;
    }
    class Headers {
        constructor(headers) {
            this.map = {};
            if (headers instanceof Headers) {
                headers.forEach((value, name) => {
                    this.append(name, value);
                });
            }
            else if (Array.isArray(headers)) {
                headers.forEach((header) => {
                    this.append(header[0], header[1]);
                });
            }
            else if (headers) {
                Object.getOwnPropertyNames(headers).forEach((name) => {
                    this.append(name, headers[name]);
                });
            }
        }
        append(name, value) {
            name = normalizeName(name);
            value = normalizeValue(value);
            var oldValue = this.map[name];
            this.map[name] = oldValue ? oldValue + ", " + value : value;
        }
        delete(name) {
            delete this.map[normalizeName(name)];
        }
        has(name) {
            return this.map.hasOwnProperty(normalizeName(name));
        }
        get(name) {
            name = normalizeName(name);
            return this.has(name) ? this.map[name] : null;
        }
        set(name, value) {
            this.map[normalizeName(name)] = normalizeValue(value);
        }
        forEach(callback, thisArg) {
            for (var name in this.map) {
                if (this.map.hasOwnProperty(name)) {
                    callback.call(thisArg, this.map[name], name, this);
                }
            }
        }
        keys() {
            var items = [];
            this.forEach(function (value, name) {
                items.push(name);
            });
            return iteratorFor(items);
        }
        values() {
            var items = [];
            this.forEach(function (value) {
                items.push(value);
            });
            return iteratorFor(items);
        }
        entries() {
            var items = [];
            this.forEach(function (value, name) {
                items.push([name, value]);
            });
            return iteratorFor(items);
        }
        [Symbol.iterator]() {
            return this.entries();
        }
    }

    /// <reference lib="dom" />
    function getGlobals() {
        if (typeof self !== "undefined") {
            return self;
        }
        else if (typeof window !== "undefined") {
            return window;
        }
        else if (typeof globalThis !== "undefined") {
            return globalThis;
        }
        return undefined;
    }
    const globals = getGlobals();

    const m = {
        Headers,
    };
    // Add classes to global scope
    if (typeof globals !== "undefined") {
        for (const prop in m) {
            if (Object.prototype.hasOwnProperty.call(m, prop)) {
                Object.defineProperty(globals, prop, {
                    value: m[prop],
                    writable: true,
                    configurable: true,
                });
            }
        }
    }

    exports.Headers = Headers;

}));
//# sourceMappingURL=polyfill.es6.js.map

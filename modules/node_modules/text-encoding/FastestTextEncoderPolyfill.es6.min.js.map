{"version":3,"file":"FastestTextEncoderPolyfill.es6.min.js","sources":["../../../js/src/text-encoding/FastestTextEncoderPolyfill.js"],"sourcesContent":["/** @define {boolean} */\nvar ENCODEINTO_BUILD = true;\n\n(function(window){\n\t\"use strict\";\n\tvar log = Math.log;\n\tvar LN2 = Math.LN2;\n\tvar clz32 = Math.clz32 || function(x) {return 31 - log(x >>> 0) / LN2 | 0};\n\tvar fromCharCode = String.fromCharCode;\n\tvar patchedU8Array = window.Uint8Array || Array;\n\tvar TextEncoderPrototype = TextEncoder[\"prototype\"];\n\tvar GlobalTextEncoder = window[\"TextEncoder\"];\n\tvar globalTextEncoderPrototype;\n\tvar globalTextEncoderInstance;\n\t//////////////////////////////////////////////////////////////////////////////////////\n\tfunction encoderReplacer(nonAsciiChars){\n\t\t// make the UTF string into a binary UTF-8 encoded string\n\t\tvar point = nonAsciiChars.charCodeAt(0)|0;\n\t\tif (0xD800 <= point) {\n\t\t\tif (point < 0xDC00) {\n\t\t\t\tvar nextcode = nonAsciiChars.charCodeAt(1)|0; // defaults to 0 when NaN, causing null replacement character\n\t\t\t\t\n\t\t\t\tif (0xDC00 <= nextcode && nextcode <= 0xDFFF) {\n\t\t\t\t\t//point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;\n\t\t\t\t\tpoint = (point<<10) + nextcode - 0x35fdc00|0;\n\t\t\t\t\tif (point > 0xffff)\n\t\t\t\t\t\treturn fromCharCode(\n\t\t\t\t\t\t\t(0x1e/*0b11110*/<<3) | (point>>>18),\n\t\t\t\t\t\t\t(0x2/*0b10*/<<6) | ((point>>>12)&0x3f/*0b00111111*/),\n\t\t\t\t\t\t\t(0x2/*0b10*/<<6) | ((point>>>6)&0x3f/*0b00111111*/),\n\t\t\t\t\t\t\t(0x2/*0b10*/<<6) | (point&0x3f/*0b00111111*/)\n\t\t\t\t\t\t);\n\t\t\t\t} else point = 65533/*0b1111111111111101*/;//return '\\xEF\\xBF\\xBD';//fromCharCode(0xef, 0xbf, 0xbd);\n\t\t\t} else if (point <= 0xDFFF) {\n\t\t\t\tpoint = 65533/*0b1111111111111101*/;//return '\\xEF\\xBF\\xBD';//fromCharCode(0xef, 0xbf, 0xbd);\n\t\t\t}\n\t\t}\n\t\t/*if (point <= 0x007f) return nonAsciiChars;\n\t\telse */if (point <= 0x07ff) {\n\t\t\treturn fromCharCode((0x6<<5)|(point>>>6), (0x2<<6)|(point&0x3f));\n\t\t} else return fromCharCode(\n\t\t\t(0xe/*0b1110*/<<4) | (point>>>12),\n\t\t\t(0x2/*0b10*/<<6) | ((point>>>6)&0x3f/*0b00111111*/),\n\t\t\t(0x2/*0b10*/<<6) | (point&0x3f/*0b00111111*/)\n\t\t);\n\t}\n\tfunction TextEncoder(){};\n\tTextEncoderPrototype[\"encode\"] = function(inputString) {\n\t\t// 0xc0 => 0b11000000; 0xff => 0b11111111; 0xc0-0xff => 0b11xxxxxx\n\t\t// 0x80 => 0b10000000; 0xbf => 0b10111111; 0x80-0xbf => 0b10xxxxxx\n\t\tvar encodedString = inputString === void 0 ?  \"\" : (\"\" + inputString).replace(/[\\x80-\\uD7ff\\uDC00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g, encoderReplacer);\n\t\tvar len=encodedString.length|0, result = new patchedU8Array(len);\n\t\tvar i=0;\n\t\tfor (; i<len; i=i+1|0)\n\t\t\tresult[i] = encodedString.charCodeAt(i) |0;\n\t\treturn result;\n\t};\n\tfunction polyfill_encodeInto(inputString, u8Arr) {\n\t\tvar encodedString = inputString === void 0 ?  \"\" : (\"\" + inputString).replace(/[\\x80-\\uD7ff\\uDC00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g, encoderReplacer);\n\t\tvar len=encodedString.length|0, i=0, char=0, read=0, u8ArrLen = u8Arr.length|0, inputLength=inputString.length|0;\n\t\tif (u8ArrLen < len) len=u8ArrLen;\n\t\tputChars: {\n\t\t\tfor (; i<len; i=i+1|0) {\n\t\t\t\tchar = encodedString.charCodeAt(i) |0;\n\t\t\t\tswitch(char >>> 4) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\tcase 1:\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\tcase 4:\n\t\t\t\t\tcase 5:\n\t\t\t\t\tcase 6:\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\tread = read + 1|0;\n\t\t\t\t\t\t// extension points:\n\t\t\t\t\tcase 8:\n\t\t\t\t\tcase 9:\n\t\t\t\t\tcase 10:\n\t\t\t\t\tcase 11:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 12:\n\t\t\t\t\tcase 13:\n\t\t\t\t\t\tif ((i+1|0) < u8ArrLen) {\n\t\t\t\t\t\t\tread = read + 1|0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 14:\n\t\t\t\t\t\tif ((i+2|0) < u8ArrLen) {\n\t\t\t\t\t\t\tread = read + 1|0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 15:\n\t\t\t\t\t\tif ((i+3|0) < u8ArrLen) {\n\t\t\t\t\t\t\tread = read + 1|0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak putChars;\n\t\t\t\t}\n\t\t\t\t//read = read + ((char >>> 6) !== 2) |0;\n\t\t\t\tu8Arr[i] = char;\n\t\t\t}\n\t\t}\n\t\treturn {\"written\": i, \"read\": inputLength < read ? inputLength : read};\n\t\t// 0xc0 => 0b11000000; 0xff => 0b11111111; 0xc0-0xff => 0b11xxxxxx\n\t\t// 0x80 => 0b10000000; 0xbf => 0b10111111; 0x80-0xbf => 0b10xxxxxx\n\t\t/*var encodedString = typeof inputString == \"string\" ? inputString : inputString === void 0 ?  \"\" : \"\" + inputString;\n\t\tvar encodedLen = encodedString.length|0, u8LenLeft=u8Arr.length|0;\n\t\tvar i=-1, read=-1, code=0, point=0, nextcode=0;\n\t\ttryFast: if (2 < encodedLen && encodedLen < (u8LenLeft >> 1)) {\n\t\t\t// Skip the normal checks because we can almost certainly fit the string inside the existing buffer\n\t\t\twhile (1) {\t\t// make the UTF string into a binary UTF-8 encoded string\n\t\t\t\tpoint = encodedString.charCodeAt(read = read + 1|0)|0;\n\t\t\t\t\n\t\t\t\tif (point <= 0x007f) {\n\t\t\t\t\tif (point === 0 && encodedLen <= read) {\n\t\t\t\t\t\tread = read - 1|0;\n\t\t\t\t\t\tbreak; // we have reached the end of the string\n\t\t\t\t\t}\n\t\t\t\t\tu8Arr[i=i+1|0] = point;\n\t\t\t\t} else if (point <= 0x07ff) {\n\t\t\t\t\tu8Arr[i=i+1|0] = (0x6<<5)|(point>>>6);\n\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6)|(point&0x3f);\n\t\t\t\t} else {\n\t\t\t\t\tif (0xD800 <= point && point < 0xDC00) {\n\t\t\t\t\t\tnextcode = encodedString.charCodeAt(read)|0; // defaults to 0 when NaN, causing null replacement character\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (0xDC00 <= nextcode && nextcode <= 0xDFFF) {\n\t\t\t\t\t\t\tread = read + 1|0;\n\t\t\t\t\t\t\t//point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;\n\t\t\t\t\t\t\tpoint = (point<<10) + nextcode - 0x35fdc00|0;\n\t\t\t\t\t\t\tif (point > 0xffff) {\n\t\t\t\t\t\t\t\tu8Arr[i=i+1|0] = (0x1e<<3) | (point>>>18);\n\t\t\t\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6) | ((point>>>12)&0x3f);\n\t\t\t\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6) | ((point>>>6)&0x3f);\n\t\t\t\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6) | (point&0x3f);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (nextcode === 0 && encodedLen <= read) {\n\t\t\t\t\t\t\tbreak; // we have reached the end of the string\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpoint = 65533;//0b1111111111111101; // invalid replacement character\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tu8Arr[i=i+1|0] = (0xe<<4) | (point>>>12);\n\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6) | ((point>>>6)&0x3f);\n\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6) | (point&0x3f);\n\t\t\t\t\tif (u8LenLeft < (i + ((encodedLen - read) << 1)|0)) {\n\t\t\t\t\t\t// These 3x chars are the only way to inflate the size to 3x\n\t\t\t\t\t\tu8LenLeft = u8LenLeft - i|0;\n\t\t\t\t\t\tbreak tryFast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tu8LenLeft = 0; // skip the next for-loop \n\t\t}\n\t\t\n\t\t\n\t\tfor (; 0 < u8LenLeft; ) {\t\t// make the UTF string into a binary UTF-8 encoded string\n\t\t\tpoint = encodedString.charCodeAt(read = read + 1|0)|0;\n\t\t\t\n\t\t\tif (point <= 0x007f) {\n\t\t\t\tif (point === 0 && encodedLen <= read) {\n\t\t\t\t\tread = read - 1|0;\n\t\t\t\t\tbreak; // we have reached the end of the string\n\t\t\t\t}\n\t\t\t\tu8LenLeft = u8LenLeft - 1|0;\n\t\t\t\tu8Arr[i=i+1|0] = point;\n\t\t\t} else if (point <= 0x07ff) {\n\t\t\t\tu8LenLeft = u8LenLeft - 2|0;\n\t\t\t\tif (0 <= u8LenLeft) {\n\t\t\t\t\tu8Arr[i=i+1|0] = (0x6<<5)|(point>>>6);\n\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6)|(point&0x3f);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (0xD800 <= point) {\n\t\t\t\t\tif (point < 0xDC00) {\n\t\t\t\t\t\tnextcode = encodedString.charCodeAt(read = read + 1|0)|0; // defaults to 0 when NaN, causing null replacement character\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (0xDC00 <= nextcode && nextcode <= 0xDFFF) {\n\t\t\t\t\t\t\tread = read + 1|0;\n\t\t\t\t\t\t\t//point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;\n\t\t\t\t\t\t\tpoint = (point<<10) + nextcode - 0x35fdc00|0;\n\t\t\t\t\t\t\tif (point > 0xffff) {\n\t\t\t\t\t\t\t\tu8LenLeft = u8LenLeft - 4|0;\n\t\t\t\t\t\t\t\tif (0 <= u8LenLeft) {\n\t\t\t\t\t\t\t\t\tu8Arr[i=i+1|0] = (0x1e<<3) | (point>>>18);\n\t\t\t\t\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6) | ((point>>>12)&0x3f);\n\t\t\t\t\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6) | ((point>>>6)&0x3f);\n\t\t\t\t\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6) | (point&0x3f);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (nextcode === 0 && encodedLen <= read) {\n\t\t\t\t\t\t\tbreak; // we have reached the end of the string\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpoint = 65533;//0b1111111111111101; // invalid replacement character\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (point <= 0xDFFF) {\n\t\t\t\t\t\tpoint = 65533/*0b1111111111111101*\\/;//return '\\xEF\\xBF\\xBD';//fromCharCode(0xef, 0xbf, 0xbd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tu8LenLeft = u8LenLeft - 3|0;\n\t\t\t\tif (0 <= u8LenLeft) {\n\t\t\t\t\tu8Arr[i=i+1|0] = (0xe<<<4) | (point>>>12);\n\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6) | ((point>>>6)&0x3f);\n\t\t\t\t\tu8Arr[i=i+1|0] = (0x2<<6) | (point&0x3f);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\treturn {\"read\": read < 0 ? 0 : u8LenLeft < 0 ? read : read+1|0, \"written\": i < 0 ? 0 : i+1|0};*/\n\t};\n\tif (ENCODEINTO_BUILD) {\n\t\tTextEncoderPrototype[\"encodeInto\"] = polyfill_encodeInto;\n\t}\n\tif (!GlobalTextEncoder) {\n\t\twindow[\"TextEncoder\"] = TextEncoder;\n\t} else if (ENCODEINTO_BUILD && !(globalTextEncoderPrototype = GlobalTextEncoder[\"prototype\"])[\"encodeInto\"]) {\n\t\tglobalTextEncoderInstance = new GlobalTextEncoder;\n\t\tglobalTextEncoderPrototype[\"encodeInto\"] = function(string, u8arr) {\n\t\t\t// Unfortunately, there's no way I can think of to quickly extract the number of bits written and the number of bytes read and such\n\t\t\tvar strLen = string.length|0, u8Len = u8arr.length|0;\n\t\t\tif (strLen < ((u8Len >> 1) + 3|0)) { // in most circumstances, this means its safe. there are still edge-cases which are possible\n\t\t\t\t// in many circumstances, we can use the faster native TextEncoder\n\t\t\t\tvar res8 = globalTextEncoderInstance[\"encode\"](string);\n\t\t\t\tvar res8Len = res8.length|0;\n\t\t\t\tif (res8Len < u8Len) { // if we dont have to worry about read/written\n\t\t\t\t\tu8arr.set( res8 );\n\t\t\t\t\treturn {\n\t\t\t\t\t\t\"read\": strLen,\n\t\t\t\t\t\t\"written\": res8.length|0\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn polyfill_encodeInto(string, u8arr);\n\t\t};\n\t}\n})(typeof global == \"\" + void 0 ? typeof self == \"\" + void 0 ? this : self : global);\n"],"names":["window","globalTextEncoderPrototype","globalTextEncoderInstance","fromCharCode","String","patchedU8Array","Uint8Array","Array","TextEncoderPrototype","TextEncoder","GlobalTextEncoder","encoderReplacer","nonAsciiChars","point","charCodeAt","nextcode","polyfill_encodeInto","inputString","u8Arr","encodedString","replace","len","length","i","char","read","u8ArrLen","inputLength","putChars","written","result","string","u8arr","strLen","u8Len","res8","set","global","self","this"],"mappings":"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"}
{"version":3,"file":"FastestTextDecoderPolyfill.es6.min.js","sources":["../../../js/src/text-encoding/FastestTextDecoderPolyfill.js"],"sourcesContent":["(function (window) {\n  \"use strict\";\n  var log = Math.log;\n  var LN2 = Math.LN2;\n  var clz32 =\n    Math.clz32 ||\n    function (x) {\n      return (31 - log(x >>> 0) / LN2) | 0;\n    };\n  var fromCharCode = String.fromCharCode;\n  var Object_prototype_toString = {}.toString;\n  var NativeSharedArrayBuffer = window[\"SharedArrayBuffer\"];\n  var sharedArrayBufferString = NativeSharedArrayBuffer\n    ? Object_prototype_toString.call(NativeSharedArrayBuffer)\n    : \"\";\n  var NativeUint8Array = window.Uint8Array;\n  var patchedU8Array = NativeUint8Array || Array;\n  var arrayBufferString = Object_prototype_toString.call(\n    (NativeUint8Array ? ArrayBuffer : patchedU8Array).prototype\n  );\n  function decoderReplacer(encoded) {\n    var cp0 = encoded.charCodeAt(0),\n      codePoint = 0x110000,\n      i = 0,\n      stringLen = encoded.length | 0,\n      result = \"\";\n    switch (cp0 >>> 4) {\n      // no 1 byte sequences\n      case 12:\n      case 13:\n        codePoint = ((cp0 & 0x1f) << 6) | (encoded.charCodeAt(1) & 0x3f);\n        i = codePoint < 0x80 ? 0 : 2;\n        break;\n      case 14:\n        codePoint =\n          ((cp0 & 0x0f) << 12) |\n          ((encoded.charCodeAt(1) & 0x3f) << 6) |\n          (encoded.charCodeAt(2) & 0x3f);\n        i = codePoint < 0x800 ? 0 : 3;\n        break;\n      case 15:\n        if (cp0 >>> 3 === 30) {\n          codePoint =\n            ((cp0 & 0x07) << 18) |\n            ((encoded.charCodeAt(1) & 0x3f) << 12) |\n            ((encoded.charCodeAt(2) & 0x3f) << 6) |\n            encoded.charCodeAt(3);\n          i = codePoint < 0x10000 ? 0 : 4;\n        }\n    }\n    if (i) {\n      if (stringLen < i) {\n        i = 0;\n      } else if (codePoint < 0x10000) {\n        // BMP code point\n        result = fromCharCode(codePoint);\n      } else if (codePoint < 0x110000) {\n        codePoint = (codePoint - 0x10080) | 0; //- 0x10000|0;\n        result = fromCharCode(\n          ((codePoint >>> 10) + 0xd800) | 0, // highSurrogate\n          ((codePoint & 0x3ff) + 0xdc00) | 0 // lowSurrogate\n        );\n      } else i = 0; // to fill it in with INVALIDs\n    }\n\n    for (; i < stringLen; i = (i + 1) | 0) result += \"\\ufffd\"; // fill rest with replacement character\n\n    return result;\n  }\n  function TextDecoder(_, opts) {\n    /*this[\"ignoreBOM\"] = !!opts && !!opts[\"ignoreBOM\"]*/\n  }\n  TextDecoder[\"prototype\"][\"decode\"] = function (inputArrayOrBuffer) {\n    var buffer =\n      (inputArrayOrBuffer && inputArrayOrBuffer.buffer) || inputArrayOrBuffer;\n    var asObjectString = Object_prototype_toString.call(buffer);\n    if (\n      asObjectString !== arrayBufferString &&\n      asObjectString !== sharedArrayBufferString &&\n      inputArrayOrBuffer !== undefined\n    )\n      throw TypeError(\n        \"Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\"\n      );\n    var inputAs8 = NativeUint8Array ? new patchedU8Array(buffer) : buffer;\n    var resultingString = \"\";\n    for (\n      var index = 0 /*inputAs8[0]!==0xEF||inputAs8[1]!==0xBB||inputAs8[2]!==0xBF||this[\"ignoreBOM\"]?0:3*/,\n        len = inputAs8.length | 0;\n      index < len;\n      index = (index + 32768) | 0\n    )\n      resultingString += fromCharCode.apply(\n        0,\n        inputAs8[NativeUint8Array ? \"subarray\" : \"slice\"](\n          index,\n          (index + 32768) | 0\n        )\n      );\n\n    return resultingString.replace(\n      /[\\xc0-\\xff][\\x80-\\xbf]+|[\\x80-\\xff]/g,\n      decoderReplacer\n    );\n  };\n  if (!window[\"TextDecoder\"]) window[\"TextDecoder\"] = TextDecoder;\n})(\n  typeof global == \"\" + void 0\n    ? typeof self == \"\" + void 0\n      ? globalThis\n      : self\n    : global\n);\n"],"names":["window","fromCharCode","String","Object_prototype_toString","toString","NativeSharedArrayBuffer","sharedArrayBufferString","call","NativeUint8Array","Uint8Array","patchedU8Array","Array","arrayBufferString","ArrayBuffer","prototype","decoderReplacer","encoded","cp0","charCodeAt","codePoint","i","stringLen","length","result","TextDecoder","_","opts","inputArrayOrBuffer","buffer","asObjectString","undefined","TypeError","inputAs8","resultingString","index","len","apply","replace","global","self","globalThis"],"mappings":"wYAAA,SAAWA,GAST,IAAIC,EAAeC,OAAOD,aACtBE,EAA4B,CAAE,EAACC,SAC/BC,EAA0BL,EAA0B,kBACpDM,EAA0BD,EAC1BF,EAA0BI,KAAKF,GAC/B,GACAG,EAAmBR,EAAOS,WAC1BC,EAAiBF,GAAoBG,MACrCC,EAAoBT,EAA0BI,MAC/CC,EAAmBK,YAAcH,GAAgBI,WAEpD,SAASC,EAAgBC,GACvB,IAAIC,EAAMD,EAAQE,WAAW,GAC3BC,EAAY,QACZC,EAAI,EACJC,EAA6B,EAAjBL,EAAQM,OACpBC,EAAS,GACX,OAAQN,IAAQ,GAEd,KAAK,GACL,KAAK,GAEHG,GADAD,GAAoB,GAANF,IAAe,EAA8B,GAAxBD,EAAQE,WAAW,IACtC,IAAO,EAAI,EAC3B,MACF,KAAK,GAKHE,GAJAD,GACU,GAANF,IAAe,IACS,GAAxBD,EAAQE,WAAW,KAAc,EACV,GAAxBF,EAAQE,WAAW,IACN,KAAQ,EAAI,EAC5B,MACF,KAAK,GACCD,IAAQ,GAAM,KAMhBG,GALAD,GACU,EAANF,IAAe,IACS,GAAxBD,EAAQE,WAAW,KAAc,IACT,GAAxBF,EAAQE,WAAW,KAAc,EACnCF,EAAQE,WAAW,IACL,MAAU,EAAI,GAkBpC,IAfIE,IACEC,EAAYD,EACdA,EAAI,EACKD,EAAY,MAErBI,EAAStB,EAAakB,GACbA,EAAY,QAErBI,EAAStB,EACe,QAFxBkB,EAAaA,EAAY,MAAW,KAElB,IAAgB,EACT,OAAT,KAAZA,GAA+B,GAE9BC,EAAI,GAGNA,EAAIC,EAAWD,EAAKA,EAAI,EAAK,EAAGG,GAAU,IAEjD,OAAOA,CACR,CACD,SAASC,EAAYC,EAAGC,GAEvB,CACDF,EAAuB,UAAU,OAAI,SAAUG,GAC7C,IAAIC,EACDD,GAAsBA,EAAmBC,QAAWD,EACnDE,EAAiB1B,EAA0BI,KAAKqB,GACpD,GACEC,IAAmBjB,GACnBiB,IAAmBvB,QACIwB,IAAvBH,EAEA,MAAMI,UACJ,qHAIJ,IAFA,IAAIC,EAAWxB,EAAmB,IAAIE,EAAekB,GAAUA,EAC3DK,EAAkB,GAEhBC,EAAQ,EACVC,EAAwB,EAAlBH,EAASV,OACjBY,EAAQC,EACRD,EAASA,EAAQ,MAAS,EAE1BD,GAAmBhC,EAAamC,MAC9B,EACAJ,EAASxB,EAAmB,WAAa,SACvC0B,EACCA,EAAQ,MAAS,IAIxB,OAAOD,EAAgBI,QACrB,uCACAtB,EAEN,EACOf,EAAoB,cAAGA,EAAoB,YAAIwB,EACrD,CA1GD,QA2GSc,GAAU,QAAK,SACXC,MAAQ,QAAK,EAClBC,WACAD,KACFD"}